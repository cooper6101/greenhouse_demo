"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/index.ts
var src_exports = {};
__export(src_exports, {
  AccessTokenCreationException: () => AccessTokenCreationException,
  AddUserToOrgException: () => AddUserToOrgException,
  ApiKeyCreateException: () => ApiKeyCreateException,
  ApiKeyDeleteException: () => ApiKeyDeleteException,
  ApiKeyFetchException: () => ApiKeyFetchException,
  ApiKeyUpdateException: () => ApiKeyUpdateException,
  ApiKeyValidateException: () => ApiKeyValidateException,
  ApiKeyValidateRateLimitedException: () => ApiKeyValidateRateLimitedException,
  BadRequestException: () => BadRequestException,
  ChangeUserRoleInOrgException: () => ChangeUserRoleInOrgException,
  CreateOrgException: () => CreateOrgException,
  CreateUserException: () => CreateUserException,
  FeatureGatedException: () => FeatureGatedException,
  ForbiddenException: () => ForbiddenException,
  IncorrectMfaCodeException: () => IncorrectMfaCodeException,
  InvalidRequestFieldsException: () => InvalidRequestFieldsException,
  MagicLinkCreationException: () => MagicLinkCreationException,
  MfaNotEnabledException: () => MfaNotEnabledException,
  MigrateUserException: () => MigrateUserException,
  MigrateUserPasswordException: () => MigrateUserPasswordException,
  OrgMemberInfo: () => OrgMemberInfo,
  OrgRoleStructure: () => OrgRoleStructure,
  RateLimitedException: () => RateLimitedException,
  RemoveUserFromOrgException: () => RemoveUserFromOrgException,
  RevokePendingOrgInviteException: () => RevokePendingOrgInviteException,
  UnauthorizedException: () => UnauthorizedException,
  UnexpectedException: () => UnexpectedException,
  UpdateOrgException: () => UpdateOrgException,
  UpdateUserEmailException: () => UpdateUserEmailException,
  UpdateUserMetadataException: () => UpdateUserMetadataException,
  UpdateUserPasswordException: () => UpdateUserPasswordException,
  UserClass: () => UserClass,
  UserNotFoundException: () => UserNotFoundException,
  getApis: () => getApis,
  parseSnakeCaseToCamelCase: () => parseSnakeCaseToCamelCase,
  toOrgIdToOrgMemberInfo: () => toOrgIdToOrgMemberInfo,
  toUser: () => toUser
});
module.exports = __toCommonJS(src_exports);

// src/exceptions.ts
var CreateUserException = class extends Error {
  constructor(message) {
    super(message);
    this.fieldToErrors = JSON.parse(message);
  }
};
var MigrateUserException = class extends Error {
  constructor(message) {
    super(message);
    this.fieldToErrors = JSON.parse(message);
  }
};
var MigrateUserPasswordException = class extends Error {
  constructor(message) {
    super(message);
    this.fieldToErrors = JSON.parse(message);
  }
};
var CreateOrgException = class extends Error {
  constructor(message) {
    super(message);
    this.fieldToErrors = JSON.parse(message);
  }
};
var AddUserToOrgException = class extends Error {
  constructor(message) {
    super(message);
    this.fieldToErrors = JSON.parse(message);
  }
};
var ChangeUserRoleInOrgException = class extends Error {
  constructor(message) {
    super(message);
    this.fieldToErrors = JSON.parse(message);
  }
};
var RemoveUserFromOrgException = class extends Error {
  constructor(message) {
    super(message);
    this.fieldToErrors = JSON.parse(message);
  }
};
var UpdateOrgException = class extends Error {
  constructor(message) {
    super(message);
    this.fieldToErrors = JSON.parse(message);
  }
};
var RevokePendingOrgInviteException = class extends Error {
  constructor(message) {
    super(message);
    this.fieldToErrors = JSON.parse(message);
  }
};
var ForbiddenException = class extends Error {
  constructor(message) {
    super(message);
    this.message = message;
    this.status = 403;
  }
};
var MagicLinkCreationException = class extends Error {
  constructor(message) {
    super(message);
    this.fieldToErrors = JSON.parse(message);
  }
};
var AccessTokenCreationException = class extends Error {
  constructor(message) {
    super(message);
    this.fieldToErrors = JSON.parse(message);
  }
};
var UnauthorizedException = class extends Error {
  constructor(message) {
    super(message);
    this.message = message;
    this.status = 401;
  }
};
var UnexpectedException = class extends Error {
  constructor(message) {
    super(message);
    this.message = message;
    this.status = 503;
  }
};
var UpdateUserEmailException = class extends Error {
  constructor(message) {
    super(message);
    this.fieldToErrors = JSON.parse(message);
  }
};
var UpdateUserPasswordException = class extends Error {
  constructor(message) {
    super(message);
    this.fieldToErrors = JSON.parse(message);
  }
};
var UpdateUserMetadataException = class extends Error {
  constructor(message) {
    super(message);
    this.fieldToErrors = JSON.parse(message);
  }
};
var UserNotFoundException = class extends Error {
};
var ApiKeyValidateException = class extends Error {
  constructor(message) {
    super(message);
    this.fieldToErrors = JSON.parse(message);
  }
};
var ApiKeyValidateRateLimitedException = class extends Error {
  constructor(errorBody) {
    super(errorBody);
    const parsedErrorBody = JSON.parse(errorBody);
    this.waitSeconds = parsedErrorBody.wait_seconds;
    this.userFacingError = parsedErrorBody.user_facing_error;
    this.errorCode = parsedErrorBody.error_code;
  }
};
var RateLimitedException = class extends Error {
  constructor(message) {
    super(message);
  }
};
var ApiKeyDeleteException = class extends Error {
  constructor(message) {
    super(message);
    this.fieldToErrors = JSON.parse(message);
  }
};
var ApiKeyUpdateException = class extends Error {
  constructor(message) {
    super(message);
    this.fieldToErrors = JSON.parse(message);
  }
};
var ApiKeyCreateException = class extends Error {
  constructor(message) {
    super(message);
    this.fieldToErrors = JSON.parse(message);
  }
};
var ApiKeyFetchException = class extends Error {
  constructor(message) {
    super(message);
    this.fieldToErrors = JSON.parse(message);
  }
};
var BadRequestException = class extends Error {
  constructor(message) {
    super(message);
    this.fieldToErrors = JSON.parse(message);
  }
};
var FeatureGatedException = class extends Error {
  constructor() {
    super("This feature isn't available on your current pricing plan");
  }
};
var IncorrectMfaCodeException = class extends Error {
};
var MfaNotEnabledException = class extends Error {
};
var InvalidRequestFieldsException = class extends Error {
  constructor(errorBody) {
    super("Invalid request");
    this.errorBody = JSON.parse(errorBody);
  }
};

// src/loginMethod.ts
function toLoginMethod(snake_case) {
  if (!snake_case) {
    return { loginMethod: "unknown" };
  }
  switch (snake_case.login_method) {
    case "password":
      return { loginMethod: "password" };
    case "magic_link":
      return { loginMethod: "magic_link" };
    case "social_sso":
      return { loginMethod: "social_sso", provider: snake_case.provider };
    case "email_confirmation_link":
      return { loginMethod: "email_confirmation_link" };
    case "saml_sso":
      return { loginMethod: "saml_sso", provider: snake_case.provider, orgId: snake_case.org_id };
    case "impersonation":
      return { loginMethod: "impersonation" };
    case "generated_from_backend_api":
      return { loginMethod: "generated_from_backend_api" };
    default:
      return { loginMethod: "unknown" };
  }
}

// src/user.ts
var UserClass = class _UserClass {
  constructor(user) {
    this.userId = user.userId;
    this.orgIdToUserOrgInfo = user.orgIdToOrgMemberInfo;
    this.email = user.email;
    this.firstName = user.firstName;
    this.lastName = user.lastName;
    this.username = user.username;
    this.legacyUserId = user.legacyUserId;
    this.impersonatorUserId = user.impersonatorUserId;
    this.properties = user.properties;
    this.loginMethod = user.loginMethod;
    this.activeOrgId = user.activeOrgId;
  }
  getActiveOrg() {
    if (!this.activeOrgId) {
      return void 0;
    }
    return this.getOrg(this.activeOrgId);
  }
  getActiveOrgId() {
    return this.activeOrgId;
  }
  getOrg(orgId) {
    if (!this.orgIdToUserOrgInfo) {
      return void 0;
    }
    if (!this.orgIdToUserOrgInfo.hasOwnProperty(orgId)) {
      return void 0;
    }
    return this.orgIdToUserOrgInfo[orgId];
  }
  getOrgByName(orgName) {
    if (!this.orgIdToUserOrgInfo) {
      return void 0;
    }
    const urlSafeOrgName = orgName.toLowerCase().replace(/ /g, "-");
    for (const orgId in this.orgIdToUserOrgInfo) {
      const orgMemberInfo = this.getOrg(orgId);
      if ((orgMemberInfo == null ? void 0 : orgMemberInfo.urlSafeOrgName) === urlSafeOrgName) {
        return orgMemberInfo;
      }
    }
    return void 0;
  }
  getUserProperty(key) {
    if (!this.properties || !this.properties.hasOwnProperty(key)) {
      return void 0;
    }
    return this.properties[key];
  }
  getOrgs() {
    if (!this.orgIdToUserOrgInfo) {
      return [];
    }
    return Object.values(this.orgIdToUserOrgInfo);
  }
  isImpersonating() {
    return !!this.impersonatorUserId;
  }
  isRole(orgId, role) {
    const orgMemberInfo = this.getOrg(orgId);
    if (!orgMemberInfo) {
      return false;
    }
    return orgMemberInfo.isRole(role);
  }
  isAtLeastRole(orgId, role) {
    const orgMemberInfo = this.getOrg(orgId);
    if (!orgMemberInfo) {
      return false;
    }
    return orgMemberInfo.isAtLeastRole(role);
  }
  hasPermission(orgId, permission) {
    const orgMemberInfo = this.getOrg(orgId);
    if (!orgMemberInfo) {
      return false;
    }
    return orgMemberInfo.hasPermission(permission);
  }
  hasAllPermissions(orgId, permissions) {
    const orgMemberInfo = this.getOrg(orgId);
    if (!orgMemberInfo) {
      return false;
    }
    return orgMemberInfo.hasAllPermissions(permissions);
  }
  static fromUser(user) {
    return new _UserClass(user);
  }
};
var OrgMemberInfo = class _OrgMemberInfo {
  constructor(orgId, orgName, orgMetadata, urlSafeOrgName, userAssignedRole, userInheritedRolesPlusCurrentRole, userPermissions, orgRoleStructure, userAssignedAdditionalRoles, legacyOrgId) {
    this.orgId = orgId;
    this.orgName = orgName;
    this.orgMetadata = orgMetadata;
    this.urlSafeOrgName = urlSafeOrgName;
    this.orgRoleStructure = orgRoleStructure != null ? orgRoleStructure : "single_role_in_hierarchy" /* SingleRole */;
    this.userAssignedRole = userAssignedRole;
    this.userInheritedRolesPlusCurrentRole = userInheritedRolesPlusCurrentRole;
    this.userPermissions = userPermissions;
    this.userAssignedAdditionalRoles = userAssignedAdditionalRoles != null ? userAssignedAdditionalRoles : [];
    this.legacyOrgId = legacyOrgId;
  }
  // getters
  get assignedRole() {
    return this.userAssignedRole;
  }
  get permissions() {
    return this.userPermissions;
  }
  get inheritedRolesPlusCurrentRole() {
    return this.userInheritedRolesPlusCurrentRole;
  }
  // validation methods
  isRole(role) {
    if (this.orgRoleStructure === "multi_role" /* MultiRole */) {
      return this.userAssignedRole === role || this.userAssignedAdditionalRoles.includes(role);
    } else {
      return this.userAssignedRole === role;
    }
  }
  isAtLeastRole(role) {
    if (this.orgRoleStructure === "multi_role" /* MultiRole */) {
      return this.userAssignedRole === role || this.userAssignedAdditionalRoles.includes(role);
    } else {
      return this.userInheritedRolesPlusCurrentRole.includes(role);
    }
  }
  hasPermission(permission) {
    return this.userPermissions.includes(permission);
  }
  hasAllPermissions(permissions) {
    return permissions.every((permission) => this.hasPermission(permission));
  }
  static fromJSON(json) {
    const obj = JSON.parse(json);
    try {
      return new _OrgMemberInfo(
        obj.orgId,
        obj.orgName,
        obj.orgMetadata,
        obj.urlSafeOrgName,
        obj.userAssignedRole,
        obj.userInheritedRolesPlusCurrentRole,
        obj.userPermissions,
        obj.orgRoleStructure,
        obj.userAssignedAdditionalRoles,
        obj.legacyOrgId
      );
    } catch (e) {
      console.error(
        "Unable to parse UserOrgInfo. Make sure the JSON string is a stringified `UserOrgInfo` type.",
        e
      );
      throw e;
    }
  }
};
var OrgRoleStructure = /* @__PURE__ */ ((OrgRoleStructure2) => {
  OrgRoleStructure2["SingleRole"] = "single_role_in_hierarchy";
  OrgRoleStructure2["MultiRole"] = "multi_role";
  return OrgRoleStructure2;
})(OrgRoleStructure || {});
function toUser(snake_case) {
  let orgIdToOrgMemberInfo;
  let activeOrgId;
  if (snake_case.org_member_info) {
    orgIdToOrgMemberInfo = toOrgIdToOrgMemberInfo({
      [snake_case.org_member_info.org_id]: snake_case.org_member_info
    });
    activeOrgId = snake_case.org_member_info.org_id;
  } else {
    orgIdToOrgMemberInfo = toOrgIdToOrgMemberInfo(snake_case.org_id_to_org_member_info);
    activeOrgId = void 0;
  }
  const camelCase2 = {
    userId: snake_case.user_id,
    orgIdToOrgMemberInfo,
    activeOrgId,
    email: snake_case.email,
    firstName: snake_case.first_name,
    lastName: snake_case.last_name,
    username: snake_case.username,
    legacyUserId: snake_case.legacy_user_id,
    impersonatorUserId: snake_case.impersonator_user_id,
    metadata: snake_case.metadata,
    properties: snake_case.properties,
    loginMethod: toLoginMethod(snake_case.login_method)
  };
  return camelCase2;
}
function toOrgIdToOrgMemberInfo(snake_case) {
  if (snake_case === void 0) {
    return void 0;
  }
  const camelCase2 = {};
  for (const key of Object.keys(snake_case)) {
    const snakeCaseValue = snake_case[key];
    if (snakeCaseValue) {
      camelCase2[key] = new OrgMemberInfo(
        snakeCaseValue.org_id,
        snakeCaseValue.org_name,
        snakeCaseValue.org_metadata,
        snakeCaseValue.url_safe_org_name,
        snakeCaseValue.user_role,
        snakeCaseValue.inherited_user_roles_plus_current_role,
        snakeCaseValue.user_permissions,
        snakeCaseValue.org_role_structure,
        snakeCaseValue.additional_roles,
        snakeCaseValue.legacy_org_id
      );
    }
  }
  return camelCase2;
}

// src/http.ts
var BACKEND_API_BASE_URL = "https://propelauth-api.com";
function httpRequest(authUrl, apiKey, path, method, body) {
  let headers = {
    Authorization: "Bearer " + apiKey,
    "Content-Type": "application/json",
    "X-Propelauth-url": authUrl.hostname
  };
  return fetch(BACKEND_API_BASE_URL + path, {
    method,
    headers,
    body
  }).then((response) => {
    return response.text().then((res) => {
      return {
        statusCode: response.status,
        response: res
      };
    });
  });
}

// src/utils.ts
var idRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
var hexRegex = /^[0-9a-fA-F]{32}$/i;
function isValidId(id) {
  return idRegex.test(id);
}
function isValidHex(id) {
  return hexRegex.test(id);
}
function removeBearerIfExists(token) {
  if (!token) {
    return token;
  } else if (token.toLowerCase().startsWith("bearer ")) {
    return token.substring(7);
  } else {
    return token;
  }
}
function formatQueryParameters(obj) {
  const params = new URLSearchParams();
  for (const [key, value] of Object.entries(obj)) {
    if (value !== void 0) {
      params.set(key, value);
    }
  }
  return params.toString();
}
function parseSnakeCaseToCamelCase(response) {
  let parsedObject = JSON.parse(response);
  return processKeys(parsedObject);
}
var keysForValueNotToModify = ["metadata", "org_metadata"];
function isOrgMemberInfo(value) {
  return value && typeof value === "object" && value.hasOwnProperty("orgId") && value.hasOwnProperty("orgName") && value.hasOwnProperty("urlSafeOrgName") && value.hasOwnProperty("orgMetadata") && value.hasOwnProperty("userAssignedRole") && value.hasOwnProperty("userInheritedRolesPlusCurrentRole") && value.hasOwnProperty("userPermissions");
}
function processKeys(obj) {
  let newObj = Array.isArray(obj) ? [] : {};
  for (let key in obj) {
    if (!obj.hasOwnProperty(key)) {
      continue;
    }
    let value = obj[key];
    const doNotModifyValue = keysForValueNotToModify.includes(key);
    if (!doNotModifyValue && value && typeof value === "object") {
      value = processKeys(value);
    }
    if (isOrgMemberInfo(value)) {
      value = new OrgMemberInfo(
        value["orgId"],
        value["orgName"],
        value["orgMetadata"],
        value["urlSafeOrgName"],
        value["userAssignedRole"],
        value["userInheritedRolesPlusCurrentRole"],
        value["userPermissions"],
        value["orgRoleStructure"],
        value["userAssignedAdditionalRoles"],
        value["legacyOrgId"]
      );
    }
    let newKey;
    if (key === "user_role") {
      newKey = "userAssignedRole";
    } else if (key === "inherited_user_roles_plus_current_role") {
      newKey = "userInheritedRolesPlusCurrentRole";
    } else if (key === "additional_roles") {
      newKey = "userAssignedAdditionalRoles";
    } else {
      newKey = camelCase(key);
    }
    newObj[newKey] = value;
  }
  return newObj;
}
function camelCase(key) {
  return key.replace(/_([a-z])/g, function(g) {
    return g[1].toUpperCase();
  });
}

// src/api/accessToken.ts
var ENDPOINT_PATH = "/api/backend/v1/access_token";
function createAccessToken(authUrl, integrationApiKey, createAccessTokenRequest) {
  if (!isValidId(createAccessTokenRequest.userId)) {
    throw new UserNotFoundException();
  }
  const request = {
    user_id: createAccessTokenRequest.userId,
    duration_in_minutes: createAccessTokenRequest.durationInMinutes,
    active_org_id: createAccessTokenRequest.activeOrgId
  };
  return httpRequest(authUrl, integrationApiKey, ENDPOINT_PATH, "POST", JSON.stringify(request)).then(
    (httpResponse) => {
      if (httpResponse.statusCode === 401) {
        throw new Error("integrationApiKey is incorrect");
      } else if (httpResponse.statusCode === 429) {
        throw new RateLimitedException(httpResponse.response);
      } else if (httpResponse.statusCode === 400) {
        throw new AccessTokenCreationException(httpResponse.response);
      } else if (httpResponse.statusCode === 403) {
        throw new UserNotFoundException();
      } else if (httpResponse.statusCode === 404) {
        throw new Error("Access token creation is not enabled");
      } else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
        throw new Error("Unknown error when creating access token");
      }
      return JSON.parse(httpResponse.response);
    }
  );
}

// src/api/endUserApiKeys.ts
var ENDPOINT_PATH2 = "/api/backend/v1/end_user_api_keys";
function fetchApiKey(authUrl, integrationApiKey, apiKeyId) {
  if (!isValidHex(apiKeyId)) {
    throw new ApiKeyFetchException("Invalid api key");
  }
  return httpRequest(authUrl, integrationApiKey, `${ENDPOINT_PATH2}/${apiKeyId}`, "GET").then((httpResponse) => {
    if (httpResponse.statusCode === 401) {
      throw new Error("integrationApiKey is incorrect");
    } else if (httpResponse.statusCode === 429) {
      throw new RateLimitedException(httpResponse.response);
    } else if (httpResponse.statusCode === 400) {
      throw new ApiKeyFetchException(httpResponse.response);
    } else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
      throw new Error("Unknown error when creating the end user api key");
    }
    return parseSnakeCaseToCamelCase(httpResponse.response);
  });
}
function fetchCurrentApiKeys(authUrl, integrationApiKey, apiKeyQuery) {
  const request = {
    org_id: apiKeyQuery.orgId,
    user_id: apiKeyQuery.userId,
    user_email: apiKeyQuery.userEmail,
    page_size: apiKeyQuery.pageSize,
    page_number: apiKeyQuery.pageNumber
  };
  const queryString = formatQueryParameters(request);
  return httpRequest(authUrl, integrationApiKey, `${ENDPOINT_PATH2}?${queryString}`, "GET").then((httpResponse) => {
    if (httpResponse.statusCode === 401) {
      throw new Error("integrationApiKey is incorrect");
    } else if (httpResponse.statusCode === 429) {
      throw new RateLimitedException(httpResponse.response);
    } else if (httpResponse.statusCode === 400) {
      throw new ApiKeyFetchException(httpResponse.response);
    } else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
      throw new Error("Unknown error when creating the end user api key");
    }
    return parseSnakeCaseToCamelCase(httpResponse.response);
  });
}
function fetchArchivedApiKeys(authUrl, integrationApiKey, apiKeyQuery) {
  const request = {
    org_id: apiKeyQuery.orgId,
    user_id: apiKeyQuery.userId,
    user_email: apiKeyQuery.userEmail,
    page_size: apiKeyQuery.pageSize,
    page_number: apiKeyQuery.pageNumber
  };
  const queryString = formatQueryParameters(request);
  return httpRequest(authUrl, integrationApiKey, `${ENDPOINT_PATH2}/archived?${queryString}`, "GET").then(
    (httpResponse) => {
      if (httpResponse.statusCode === 401) {
        throw new Error("integrationApiKey is incorrect");
      } else if (httpResponse.statusCode === 429) {
        throw new RateLimitedException(httpResponse.response);
      } else if (httpResponse.statusCode === 400) {
        throw new ApiKeyFetchException(httpResponse.response);
      } else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
        throw new Error("Unknown error when creating the end user api key");
      }
      return parseSnakeCaseToCamelCase(httpResponse.response);
    }
  );
}
function createApiKey(authUrl, integrationApiKey, apiKeyCreate) {
  const request = {
    org_id: apiKeyCreate.orgId,
    user_id: apiKeyCreate.userId,
    expires_at_seconds: apiKeyCreate.expiresAtSeconds,
    metadata: apiKeyCreate.metadata
  };
  return httpRequest(authUrl, integrationApiKey, `${ENDPOINT_PATH2}`, "POST", JSON.stringify(request)).then(
    (httpResponse) => {
      if (httpResponse.statusCode === 401) {
        throw new Error("integrationApiKey is incorrect");
      } else if (httpResponse.statusCode === 429) {
        throw new RateLimitedException(httpResponse.response);
      } else if (httpResponse.statusCode === 400) {
        throw new ApiKeyCreateException(httpResponse.response);
      } else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
        throw new Error("Unknown error when creating the end user api key");
      }
      return parseSnakeCaseToCamelCase(httpResponse.response);
    }
  );
}
function validateApiKey(authUrl, integrationApiKey, apiKeyToken) {
  const request = {
    api_key_token: removeBearerIfExists(apiKeyToken)
  };
  return httpRequest(authUrl, integrationApiKey, `${ENDPOINT_PATH2}/validate`, "POST", JSON.stringify(request)).then(
    (httpResponse) => {
      if (httpResponse.statusCode === 401) {
        throw new Error("integrationApiKey is incorrect");
      } else if (httpResponse.statusCode === 400) {
        throw new ApiKeyValidateException(httpResponse.response);
      } else if (httpResponse.statusCode === 429) {
        let rateLimitError;
        try {
          rateLimitError = new ApiKeyValidateRateLimitedException(httpResponse.response);
        } catch (SyntaxError) {
          throw new RateLimitedException(httpResponse.response);
        }
        throw rateLimitError;
      } else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
        throw new Error("Unknown error when updating the end user api key");
      }
      return parseSnakeCaseToCamelCase(httpResponse.response);
    }
  );
}
function updateApiKey(authUrl, integrationApiKey, apiKeyId, apiKeyUpdate) {
  if (!isValidHex(apiKeyId)) {
    throw new ApiKeyUpdateException("Invalid api key");
  }
  const request = {
    expires_at_seconds: apiKeyUpdate.expiresAtSeconds,
    metadata: apiKeyUpdate.metadata
  };
  return httpRequest(
    authUrl,
    integrationApiKey,
    `${ENDPOINT_PATH2}/${apiKeyId}`,
    "PATCH",
    JSON.stringify(request)
  ).then((httpResponse) => {
    if (httpResponse.statusCode === 401) {
      throw new Error("integrationApiKey is incorrect");
    } else if (httpResponse.statusCode === 429) {
      throw new RateLimitedException(httpResponse.response);
    } else if (httpResponse.statusCode === 400) {
      throw new ApiKeyUpdateException(httpResponse.response);
    } else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
      throw new Error("Unknown error when updating the end user api key");
    }
    return true;
  });
}
function deleteApiKey(authUrl, integrationApiKey, apiKeyId) {
  if (!isValidHex(apiKeyId)) {
    throw new ApiKeyDeleteException("Invalid api key");
  }
  return httpRequest(authUrl, integrationApiKey, `${ENDPOINT_PATH2}/${apiKeyId}`, "DELETE").then((httpResponse) => {
    if (httpResponse.statusCode === 401) {
      throw new Error("integrationApiKey is incorrect");
    } else if (httpResponse.statusCode === 429) {
      throw new RateLimitedException(httpResponse.response);
    } else if (httpResponse.statusCode === 400) {
      throw new ApiKeyDeleteException(httpResponse.response);
    } else if (httpResponse.statusCode === 404) {
      return false;
    } else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
      throw new Error("Unknown error when deleting the end user api key");
    }
    return true;
  });
}

// src/api/mfa/verifyTotp.ts
var STEP_UP_VERIFY_TOTP_ENDPOINT_PATH = "/api/backend/v1/mfa/step-up/verify-totp";
function verifyStepUpTotpChallenge(authUrl, integrationApiKey, verifyTotpChallengeRequest) {
  const request = {
    action_type: verifyTotpChallengeRequest.actionType,
    user_id: verifyTotpChallengeRequest.userId,
    code: verifyTotpChallengeRequest.code,
    grant_type: verifyTotpChallengeRequest.grantType,
    valid_for_seconds: verifyTotpChallengeRequest.validForSeconds
  };
  return httpRequest(
    authUrl,
    integrationApiKey,
    STEP_UP_VERIFY_TOTP_ENDPOINT_PATH,
    "POST",
    JSON.stringify(request)
  ).then((httpResponse) => {
    if (httpResponse.statusCode && httpResponse.statusCode < 400) {
      const responseData = JSON.parse(httpResponse.response);
      return {
        stepUpGrant: responseData.step_up_grant
      };
    }
    const errorResponse = httpResponse.response ? JSON.parse(httpResponse.response) : {};
    if (httpResponse.statusCode === 401) {
      throw new UnauthorizedException("integrationApiKey is incorrect");
    } else if (errorResponse.error_code === "user_not_found") {
      throw new UserNotFoundException();
    } else if (errorResponse.error_code === "mfa_not_enabled") {
      throw new MfaNotEnabledException();
    } else if (errorResponse.error_code === "incorrect_mfa_code") {
      throw new IncorrectMfaCodeException();
    } else if (errorResponse.error_code === "invalid_request_fields") {
      throw new InvalidRequestFieldsException(httpResponse.response);
    } else if (errorResponse.error_code === "feature_gated") {
      throw new FeatureGatedException();
    } else {
      throw new UnexpectedException("Unknown error when verifying the TOTP challenge");
    }
  });
}

// src/api/mfa/verifyGrant.ts
var STEP_UP_VERIFY_GRANT_ENDPOINT_PATH = "/api/backend/v1/mfa/step-up/verify-grant";
function verifyStepUpGrant(authUrl, integrationApiKey, verifyStepUpGrantRequest) {
  const request = {
    action_type: verifyStepUpGrantRequest.actionType,
    user_id: verifyStepUpGrantRequest.userId,
    grant: verifyStepUpGrantRequest.grant
  };
  return httpRequest(
    authUrl,
    integrationApiKey,
    STEP_UP_VERIFY_GRANT_ENDPOINT_PATH,
    "POST",
    JSON.stringify(request)
  ).then((httpResponse) => {
    if (httpResponse.statusCode && httpResponse.statusCode < 400) {
      return {
        success: true
      };
    }
    let errorResponse = {};
    try {
      errorResponse = httpResponse.response ? JSON.parse(httpResponse.response) : {};
    } catch (e) {
      console.error("Failed to parse error response", e);
      errorResponse = {};
    }
    if (httpResponse.statusCode === 401 || errorResponse.error_code === "unauthorized") {
      throw new UnauthorizedException("integrationApiKey is incorrect");
    } else if (httpResponse.statusCode === 429) {
      throw new RateLimitedException(httpResponse.response);
    } else if (errorResponse.error_code === "invalid_request_fields") {
      const fieldToErrors = errorResponse.field_errors || {};
      if (fieldToErrors["grant"] == "grant_not_found") {
        return {
          success: false
        };
      } else {
        throw new BadRequestException(httpResponse.response);
      }
    } else if (errorResponse.error_code === "feature_gated") {
      throw new FeatureGatedException();
    } else {
      throw new UnexpectedException("Unknown error when verifying step up grant");
    }
  });
}

// src/api/magicLink.ts
var ENDPOINT_PATH3 = "/api/backend/v1/magic_link";
function createMagicLink(authUrl, integrationApiKey, createMagicLinkRequest) {
  const request = {
    email: createMagicLinkRequest.email,
    redirect_to_url: createMagicLinkRequest.redirectToUrl,
    expires_in_hours: createMagicLinkRequest.expiresInHours,
    create_new_user_if_one_doesnt_exist: createMagicLinkRequest.createNewUserIfOneDoesntExist
  };
  return httpRequest(authUrl, integrationApiKey, ENDPOINT_PATH3, "POST", JSON.stringify(request)).then(
    (httpResponse) => {
      if (httpResponse.statusCode === 401) {
        throw new Error("integrationApiKey is incorrect");
      } else if (httpResponse.statusCode === 429) {
        throw new RateLimitedException(httpResponse.response);
      } else if (httpResponse.statusCode === 400) {
        throw new MagicLinkCreationException(httpResponse.response);
      } else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
        throw new Error("Unknown error when creating magic link");
      }
      return JSON.parse(httpResponse.response);
    }
  );
}

// src/api/migrateUser.ts
var ENDPOINT_PATH4 = "/api/backend/v1/migrate_user";
function migrateUserFromExternalSource(authUrl, integrationApiKey, migrateUserFromExternalSourceRequest) {
  const {
    email,
    emailConfirmed: email_confirmed,
    existingUserId: existing_user_id,
    existingPasswordHash: existing_password_hash,
    existingMfaBase32EncodedSecret: existing_mfa_base32_encoded_secret,
    askUserToUpdatePasswordOnLogin: update_password_required,
    enabled,
    firstName: first_name,
    lastName: last_name,
    username,
    pictureUrl: picture_url,
    properties
  } = migrateUserFromExternalSourceRequest;
  const request = {
    email,
    email_confirmed,
    existing_user_id,
    existing_password_hash,
    existing_mfa_base32_encoded_secret,
    update_password_required,
    enabled,
    first_name,
    last_name,
    username,
    picture_url,
    properties
  };
  return httpRequest(authUrl, integrationApiKey, `${ENDPOINT_PATH4}/`, "POST", JSON.stringify(request)).then(
    (httpResponse) => {
      if (httpResponse.statusCode === 401) {
        throw new Error("integrationApiKey is incorrect");
      } else if (httpResponse.statusCode === 429) {
        throw new RateLimitedException(httpResponse.response);
      } else if (httpResponse.statusCode === 400) {
        throw new MigrateUserException(httpResponse.response);
      } else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
        throw new Error("Unknown error when migrating user");
      }
      return parseSnakeCaseToCamelCase(httpResponse.response);
    }
  );
}
function migrateUserPassword(authUrl, integrationApiKey, migrateUserPasswordRequest) {
  if (!isValidId(migrateUserPasswordRequest.userId)) {
    return Promise.resolve(false);
  }
  const request = {
    user_id: migrateUserPasswordRequest.userId,
    password_hash: migrateUserPasswordRequest.passwordHash
  };
  return httpRequest(authUrl, integrationApiKey, `${ENDPOINT_PATH4}/password`, "POST", JSON.stringify(request)).then(
    (httpResponse) => {
      if (httpResponse.statusCode === 401) {
        throw new Error("integrationApiKey is incorrect");
      } else if (httpResponse.statusCode === 429) {
        throw new RateLimitedException(httpResponse.response);
      } else if (httpResponse.statusCode === 400) {
        throw new MigrateUserPasswordException(httpResponse.response);
      } else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
        throw new Error("Unknown error when migrating user password");
      }
      return parseSnakeCaseToCamelCase(httpResponse.response);
    }
  );
}

// src/api/org.ts
var BASE_ENDPOINT_PATH = "/api/backend/v1";
var ORG_ENDPOINT_PATH = BASE_ENDPOINT_PATH + "/org";
function fetchOrg(authUrl, integrationApiKey, orgId) {
  if (!isValidId(orgId)) {
    return Promise.resolve(null);
  }
  return httpRequest(authUrl, integrationApiKey, `${ORG_ENDPOINT_PATH}/${orgId}`, "GET").then((httpResponse) => {
    if (httpResponse.statusCode === 401) {
      throw new Error("integrationApiKey is incorrect");
    } else if (httpResponse.statusCode === 429) {
      throw new RateLimitedException(httpResponse.response);
    } else if (httpResponse.statusCode === 404) {
      return null;
    } else if (httpResponse.statusCode === 426) {
      throw new Error(
        "Cannot use organizations unless B2B support is enabled. Enable it in your PropelAuth dashboard."
      );
    } else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
      throw new Error("Unknown error when fetching org");
    }
    return parseSnakeCaseToCamelCase(httpResponse.response);
  });
}
function fetchCustomRoleMappings(authUrl, integrationApiKey) {
  return httpRequest(authUrl, integrationApiKey, "/api/backend/v1/custom_role_mappings", "GET").then(
    (httpResponse) => {
      if (httpResponse.statusCode === 401) {
        throw new Error("integrationApiKey is incorrect");
      } else if (httpResponse.statusCode === 429) {
        throw new RateLimitedException(httpResponse.response);
      } else if (httpResponse.statusCode === 426) {
        throw new Error(
          "Cannot use organizations unless B2B support is enabled. Enable it in your PropelAuth dashboard."
        );
      } else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
        throw new Error("Unknown error when fetching custom role mappings");
      }
      return parseSnakeCaseToCamelCase(httpResponse.response);
    }
  );
}
function fetchPendingInvites(authUrl, integrationApiKey, params) {
  const queryParams = new URLSearchParams();
  if (params == null ? void 0 : params.orgId) {
    queryParams.set("org_id", params.orgId);
  }
  if (params == null ? void 0 : params.pageSize) {
    queryParams.set("page_size", params.pageSize.toString());
  }
  if (params == null ? void 0 : params.pageNumber) {
    queryParams.set("page_number", params.pageNumber.toString());
  }
  const path = `/api/backend/v1/pending_org_invites?${queryParams.toString()}`;
  return httpRequest(authUrl, integrationApiKey, path, "GET").then((httpResponse) => {
    if (httpResponse.statusCode === 401) {
      throw new Error("integrationApiKey is incorrect");
    } else if (httpResponse.statusCode === 429) {
      throw new RateLimitedException(httpResponse.response);
    } else if (httpResponse.statusCode === 426) {
      throw new Error(
        "Cannot use organizations unless B2B support is enabled. Enable it in your PropelAuth dashboard."
      );
    } else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
      throw new Error("Unknown error when fetching pending invites");
    }
    return parseSnakeCaseToCamelCase(httpResponse.response);
  });
}
function fetchSamlSpMetadata(authUrl, integrationApiKey, orgId) {
  const path = BASE_ENDPOINT_PATH + `/saml_sp_metadata/${orgId}`;
  return httpRequest(authUrl, integrationApiKey, path, "GET").then((httpResponse) => {
    if (httpResponse.statusCode === 401) {
      throw new Error("integrationApiKey is incorrect");
    } else if (httpResponse.statusCode === 429) {
      throw new RateLimitedException(httpResponse.response);
    } else if (httpResponse.statusCode === 426) {
      throw new Error(
        "Cannot use organizations unless B2B support is enabled. Enable it in your PropelAuth dashboard."
      );
    } else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
      throw new Error("Unknown error when fetching custom role mappings");
    }
    return parseSnakeCaseToCamelCase(httpResponse.response);
  });
}
function fetchOrgByQuery(authUrl, integrationApiKey, query) {
  const request = {
    page_size: query.pageSize,
    page_number: query.pageNumber,
    order_by: query.orderBy,
    name: query.name,
    legacy_org_id: query.legacyOrgId,
    domain: query.domain
  };
  return httpRequest(authUrl, integrationApiKey, `${ORG_ENDPOINT_PATH}/query`, "POST", JSON.stringify(request)).then(
    (httpResponse) => {
      if (httpResponse.statusCode === 401) {
        throw new Error("integrationApiKey is incorrect");
      } else if (httpResponse.statusCode === 429) {
        throw new RateLimitedException(httpResponse.response);
      } else if (httpResponse.statusCode === 400) {
        throw new Error("Invalid query " + httpResponse.response);
      } else if (httpResponse.statusCode === 426) {
        throw new Error(
          "Cannot use organizations unless B2B support is enabled. Enable it in your PropelAuth dashboard."
        );
      } else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
        throw new Error("Unknown error when fetching orgs by query");
      }
      return JSON.parse(httpResponse.response, function(key, value) {
        if (key === "org_id") {
          this.orgId = value;
        } else if (key === "org_name") {
          this.name = value;
        } else if (key === "max_users") {
          this.maxUsers = value;
        } else if (key === "legacy_org_id") {
          this.legacyOrgId = value;
        } else if (key === "total_orgs") {
          this.totalOrgs = value;
        } else if (key === "current_page") {
          this.currentPage = value;
        } else if (key === "page_size") {
          this.pageSize = value;
        } else if (key === "has_more_results") {
          this.hasMoreResults = value;
        } else {
          return value;
        }
      });
    }
  );
}
function createOrg(authUrl, integrationApiKey, createOrgRequest) {
  const {
    name,
    domain,
    enableAutoJoiningByDomain = false,
    membersMustHaveMatchingDomain = false,
    maxUsers,
    customRoleMappingName,
    legacyOrgId
  } = createOrgRequest;
  const request = {
    name,
    enable_auto_joining_by_domain: enableAutoJoiningByDomain,
    members_must_have_matching_domain: membersMustHaveMatchingDomain
  };
  if (domain) {
    request["domain"] = domain;
  }
  if (maxUsers) {
    request["max_users"] = maxUsers;
  }
  if (legacyOrgId) {
    request["legacy_org_id"] = legacyOrgId;
  }
  if (customRoleMappingName) {
    request["custom_role_mapping_name"] = customRoleMappingName;
  }
  return httpRequest(authUrl, integrationApiKey, `${ORG_ENDPOINT_PATH}/`, "POST", JSON.stringify(request)).then(
    (httpResponse) => {
      if (httpResponse.statusCode === 401) {
        throw new Error("integrationApiKey is incorrect");
      } else if (httpResponse.statusCode === 429) {
        throw new RateLimitedException(httpResponse.response);
      } else if (httpResponse.statusCode === 400) {
        throw new CreateOrgException(httpResponse.response);
      } else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
        throw new Error("Unknown error when creating org");
      }
      return parseSnakeCaseToCamelCase(httpResponse.response);
    }
  );
}
function addUserToOrg(authUrl, integrationApiKey, addUserToOrgRequest) {
  var _a;
  const request = {
    user_id: addUserToOrgRequest.userId,
    org_id: addUserToOrgRequest.orgId,
    role: addUserToOrgRequest.role,
    additional_roles: (_a = addUserToOrgRequest.additionalRoles) != null ? _a : []
  };
  return httpRequest(authUrl, integrationApiKey, `${ORG_ENDPOINT_PATH}/add_user`, "POST", JSON.stringify(request)).then(
    (httpResponse) => {
      if (httpResponse.statusCode === 401) {
        throw new Error("integrationApiKey is incorrect");
      } else if (httpResponse.statusCode === 429) {
        throw new RateLimitedException(httpResponse.response);
      } else if (httpResponse.statusCode === 400) {
        throw new AddUserToOrgException(httpResponse.response);
      } else if (httpResponse.statusCode === 404) {
        return false;
      } else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
        throw new Error("Unknown error when adding user to org");
      }
      return true;
    }
  );
}
function changeUserRoleInOrg(authUrl, integrationApiKey, changeUserRoleInOrgRequest) {
  var _a;
  const request = {
    user_id: changeUserRoleInOrgRequest.userId,
    org_id: changeUserRoleInOrgRequest.orgId,
    role: changeUserRoleInOrgRequest.role,
    additional_roles: (_a = changeUserRoleInOrgRequest.additionalRoles) != null ? _a : []
  };
  return httpRequest(
    authUrl,
    integrationApiKey,
    `${ORG_ENDPOINT_PATH}/change_role`,
    "POST",
    JSON.stringify(request)
  ).then((httpResponse) => {
    if (httpResponse.statusCode === 401) {
      throw new Error("integrationApiKey is incorrect");
    } else if (httpResponse.statusCode === 429) {
      throw new RateLimitedException(httpResponse.response);
    } else if (httpResponse.statusCode === 400) {
      throw new ChangeUserRoleInOrgException(httpResponse.response);
    } else if (httpResponse.statusCode === 404) {
      return false;
    } else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
      throw new Error("Unknown error when changing users role in org");
    }
    return true;
  });
}
function removeUserFromOrg(authUrl, integrationApiKey, removeUserFromOrgRequest) {
  const request = {
    user_id: removeUserFromOrgRequest.userId,
    org_id: removeUserFromOrgRequest.orgId
  };
  return httpRequest(
    authUrl,
    integrationApiKey,
    `${ORG_ENDPOINT_PATH}/remove_user`,
    "POST",
    JSON.stringify(request)
  ).then((httpResponse) => {
    if (httpResponse.statusCode === 401) {
      throw new Error("integrationApiKey is incorrect");
    } else if (httpResponse.statusCode === 429) {
      throw new RateLimitedException(httpResponse.response);
    } else if (httpResponse.statusCode === 400) {
      throw new RemoveUserFromOrgException(httpResponse.response);
    } else if (httpResponse.statusCode === 404) {
      return false;
    } else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
      throw new Error("Unknown error when removing users from org");
    }
    return true;
  });
}
function allowOrgToSetupSamlConnection(authUrl, integrationApiKey, orgId) {
  if (!isValidId(orgId)) {
    return Promise.resolve(false);
  }
  return httpRequest(authUrl, integrationApiKey, `${ORG_ENDPOINT_PATH}/${orgId}/allow_saml`, "POST").then(
    (httpResponse) => {
      if (httpResponse.statusCode === 401) {
        throw new Error("integrationApiKey is incorrect");
      } else if (httpResponse.statusCode === 429) {
        throw new RateLimitedException(httpResponse.response);
      } else if (httpResponse.statusCode === 404) {
        return false;
      } else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
        throw new Error("Unknown error when allowing org to setup SAML connection");
      }
      return true;
    }
  );
}
function disallowOrgToSetupSamlConnection(authUrl, integrationApiKey, orgId) {
  if (!isValidId(orgId)) {
    return Promise.resolve(false);
  }
  return httpRequest(authUrl, integrationApiKey, `${ORG_ENDPOINT_PATH}/${orgId}/disallow_saml`, "POST").then(
    (httpResponse) => {
      if (httpResponse.statusCode === 401) {
        throw new Error("integrationApiKey is incorrect");
      } else if (httpResponse.statusCode === 429) {
        throw new RateLimitedException(httpResponse.response);
      } else if (httpResponse.statusCode === 404) {
        return false;
      } else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
        throw new Error("Unknown error when disallowing org to setup SAML connection");
      }
      return true;
    }
  );
}
function createOrgSamlConnectionLink(authUrl, integrationApiKey, orgId, expiresInSeconds) {
  return __async(this, null, function* () {
    if (!isValidId(orgId)) {
      return Promise.reject(new Error("Invalid orgId"));
    }
    const request = {
      expires_in_seconds: expiresInSeconds
    };
    const response = yield httpRequest(
      authUrl,
      integrationApiKey,
      `${ORG_ENDPOINT_PATH}/${orgId}/create_saml_connection_link`,
      "POST",
      JSON.stringify(request)
    );
    if (response.statusCode === 401) {
      throw new Error("integrationApiKey is incorrect");
    } else if (response.statusCode === 429) {
      throw new RateLimitedException(response.response);
    } else if (response.statusCode === 404) {
      throw new Error("Org not found");
    } else if (response.statusCode && response.statusCode >= 400) {
      throw new Error(`Error when creating SAML connection link: ${response.response}`);
    }
    return JSON.parse(response.response);
  });
}
function setSamlIdpMetadata(authUrl, integrationApiKey, orgId, setSamlIdpMetadataRequest) {
  if (!isValidId(orgId)) {
    return Promise.resolve(false);
  }
  let request = {
    org_id: orgId,
    idp_entity_id: setSamlIdpMetadataRequest.idpEntityId,
    idp_sso_url: setSamlIdpMetadataRequest.idpSsoUrl,
    idp_certificate: setSamlIdpMetadataRequest.idpCertificate,
    provider: setSamlIdpMetadataRequest.provider
  };
  return httpRequest(
    authUrl,
    integrationApiKey,
    `${BASE_ENDPOINT_PATH}/saml_idp_metadata`,
    "POST",
    JSON.stringify(request)
  ).then(
    (httpResponse) => {
      if (httpResponse.statusCode === 401) {
        throw new Error("integrationApiKey is incorrect");
      } else if (httpResponse.statusCode === 429) {
        throw new RateLimitedException(httpResponse.response);
      } else if (httpResponse.statusCode === 400) {
        throw new UpdateOrgException(httpResponse.response);
      } else if (httpResponse.statusCode === 404) {
        return false;
      } else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
        throw new Error("Unknown error when setting the SAML IdP metadata for an org's SAML connection");
      }
      return true;
    }
  );
}
function samlGoLive(authUrl, integrationApiKey, orgId) {
  if (!isValidId(orgId)) {
    return Promise.resolve(false);
  }
  return httpRequest(authUrl, integrationApiKey, `${BASE_ENDPOINT_PATH}/saml_idp_metadata/go_live/${orgId}`, "POST").then(
    (httpResponse) => {
      if (httpResponse.statusCode === 401) {
        throw new Error("integrationApiKey is incorrect");
      } else if (httpResponse.statusCode === 429) {
        throw new RateLimitedException(httpResponse.response);
      } else if (httpResponse.statusCode === 404) {
        return false;
      } else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
        throw new Error("Unknown error when setting orgs SAML connection to go live");
      }
      return true;
    }
  );
}
function updateOrg(authUrl, integrationApiKey, updateOrgRequest) {
  if (!isValidId(updateOrgRequest.orgId)) {
    return Promise.resolve(false);
  }
  const request = {
    name: updateOrgRequest.name,
    can_setup_saml: updateOrgRequest.canSetupSaml,
    metadata: updateOrgRequest.metadata,
    max_users: updateOrgRequest.maxUsers,
    autojoin_by_domain: updateOrgRequest.canJoinOnEmailDomainMatch,
    restrict_to_domain: updateOrgRequest.membersMustHaveEmailDomainMatch,
    domain: updateOrgRequest.domain,
    legacy_org_id: updateOrgRequest.legacyOrgId,
    require_2fa_by: updateOrgRequest.require2faBy,
    extra_domains: updateOrgRequest.extraDomains
  };
  return httpRequest(
    authUrl,
    integrationApiKey,
    `${ORG_ENDPOINT_PATH}/${updateOrgRequest.orgId}`,
    "PUT",
    JSON.stringify(request)
  ).then((httpResponse) => {
    if (httpResponse.statusCode === 401) {
      throw new Error("integrationApiKey is incorrect");
    } else if (httpResponse.statusCode === 429) {
      throw new RateLimitedException(httpResponse.response);
    } else if (httpResponse.statusCode === 400) {
      throw new UpdateOrgException(httpResponse.response);
    } else if (httpResponse.statusCode === 404) {
      return false;
    } else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
      throw new Error("Unknown error when updating org");
    }
    return true;
  });
}
function subscribeOrgToRoleMapping(authUrl, integrationApiKey, orgId, customRoleMappingName) {
  if (!isValidId(orgId)) {
    return Promise.resolve(false);
  }
  const request = {
    custom_role_mapping_name: customRoleMappingName
  };
  return httpRequest(authUrl, integrationApiKey, `${ORG_ENDPOINT_PATH}/${orgId}`, "PUT", JSON.stringify(request)).then(
    (httpResponse) => {
      if (httpResponse.statusCode === 401) {
        throw new Error("integrationApiKey is incorrect");
      } else if (httpResponse.statusCode === 429) {
        throw new RateLimitedException(httpResponse.response);
      } else if (httpResponse.statusCode === 400) {
        throw new UpdateOrgException(httpResponse.response);
      } else if (httpResponse.statusCode === 404) {
        return false;
      } else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
        throw new Error("Unknown error when subscribing an org to a role mapping");
      }
      return true;
    }
  );
}
function deleteOrg(authUrl, integrationApiKey, orgId) {
  if (!isValidId(orgId)) {
    return Promise.resolve(false);
  }
  return httpRequest(authUrl, integrationApiKey, `${ORG_ENDPOINT_PATH}/${orgId}`, "DELETE").then((httpResponse) => {
    if (httpResponse.statusCode === 401) {
      throw new Error("integrationApiKey is incorrect");
    } else if (httpResponse.statusCode === 429) {
      throw new RateLimitedException(httpResponse.response);
    } else if (httpResponse.statusCode === 404) {
      return false;
    } else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
      throw new Error("Unknown error when deleting org");
    }
    return true;
  });
}
function revokePendingOrgInvite(authUrl, integrationApiKey, revokePendingOrgInviteRequest) {
  const request = {
    invitee_email: revokePendingOrgInviteRequest.inviteeEmail,
    org_id: revokePendingOrgInviteRequest.orgId
  };
  return httpRequest(
    authUrl,
    integrationApiKey,
    `/api/backend/v1/pending_org_invites`,
    "DELETE",
    JSON.stringify(request)
  ).then((httpResponse) => {
    if (httpResponse.statusCode === 401) {
      throw new Error("integrationApiKey is incorrect");
    } else if (httpResponse.statusCode === 429) {
      throw new RateLimitedException(httpResponse.response);
    } else if (httpResponse.statusCode === 400) {
      throw new RevokePendingOrgInviteException(httpResponse.response);
    } else if (httpResponse.statusCode === 404) {
      return false;
    } else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
      throw new Error("Unknown error when revoking org invite");
    }
    return true;
  });
}
function deleteSamlConnection(authUrl, integrationApiKey, orgId) {
  if (!isValidId(orgId)) {
    return Promise.resolve(false);
  }
  return httpRequest(
    authUrl,
    integrationApiKey,
    `${BASE_ENDPOINT_PATH}/saml_idp_metadata/${orgId}`,
    "DELETE"
  ).then((httpResponse) => {
    if (httpResponse.statusCode === 401) {
      throw new Error("integrationApiKey is incorrect");
    } else if (httpResponse.statusCode === 429) {
      throw new RateLimitedException(httpResponse.response);
    } else if (httpResponse.statusCode === 400) {
      throw new RevokePendingOrgInviteException(httpResponse.response);
    } else if (httpResponse.statusCode === 404) {
      return false;
    } else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
      throw new Error("Unknown error when deleting SAML connection");
    }
    return true;
  });
}

// src/api/tokenVerificationMetadata.ts
var ENDPOINT_PATH5 = "/api/v1/token_verification_metadata";
function fetchTokenVerificationMetadata(authUrl, integrationApiKey, manualTokenVerificationMetadata) {
  if (manualTokenVerificationMetadata) {
    return Promise.resolve(manualTokenVerificationMetadata);
  }
  return httpRequest(authUrl, integrationApiKey, ENDPOINT_PATH5, "GET").then((httpResponse) => {
    if (httpResponse.statusCode === 401) {
      console.error("Your API key is incorrect");
      throw new Error("integrationApiKey is incorrect");
    } else if (httpResponse.statusCode === 429) {
      throw new RateLimitedException(httpResponse.response);
    } else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
      console.error(`Error fetching token verification metadata: ${httpResponse.statusCode}`);
      throw new Error("Unknown error when fetching token verification metadata");
    }
    const jsonParse = JSON.parse(httpResponse.response);
    return {
      verifierKey: jsonParse.verifier_key_pem,
      issuer: formatIssuer(authUrl)
    };
  });
}
function formatIssuer(authUrl) {
  return authUrl.origin;
}

// src/api/user.ts
var ENDPOINT_PATH6 = "/api/backend/v1/user";
function fetchUserMetadataByQuery(authUrl, integrationApiKey, pathParam, query) {
  const queryString = formatQueryParameters(query);
  return httpRequest(authUrl, integrationApiKey, `${ENDPOINT_PATH6}/${pathParam}?${queryString}`, "GET").then(
    (httpResponse) => {
      if (httpResponse.statusCode === 401) {
        throw new Error("integrationApiKey is incorrect");
      } else if (httpResponse.statusCode === 429) {
        throw new RateLimitedException(httpResponse.response);
      } else if (httpResponse.statusCode === 404) {
        return null;
      } else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
        throw new Error("Unknown error when fetching user metadata");
      }
      return parseSnakeCaseToCamelCase(httpResponse.response);
    }
  );
}
function fetchUserMetadataByUserIdWithIdCheck(authUrl, integrationApiKey, userId, includeOrgs) {
  if (isValidId(userId)) {
    return fetchUserMetadataByQuery(authUrl, integrationApiKey, userId, { include_orgs: includeOrgs || false });
  } else {
    return Promise.resolve(null);
  }
}
function fetchUsersByQuery(authUrl, integrationApiKey, query) {
  const queryParams = {
    page_size: query.pageSize,
    page_number: query.pageNumber,
    order_by: query.orderBy,
    email_or_username: query.emailOrUsername,
    include_orgs: query.includeOrgs,
    legacy_user_id: query.legacyUserId
  };
  const q = formatQueryParameters(queryParams);
  return httpRequest(authUrl, integrationApiKey, `${ENDPOINT_PATH6}/query?${q}`, "GET").then((httpResponse) => {
    if (httpResponse.statusCode === 401) {
      throw new Error("integrationApiKey is incorrect");
    } else if (httpResponse.statusCode === 429) {
      throw new RateLimitedException(httpResponse.response);
    } else if (httpResponse.statusCode === 400) {
      throw new Error("Invalid query " + httpResponse.response);
    } else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
      throw new Error("Unknown error when fetching users by query");
    }
    return parseSnakeCaseToCamelCase(httpResponse.response);
  });
}
function fetchUsersInOrg(authUrl, integrationApiKey, query) {
  if (!isValidId(query.orgId)) {
    const emptyResponse = {
      users: [],
      totalUsers: 0,
      currentPage: query.pageNumber || 0,
      pageSize: query.pageSize || 10,
      hasMoreResults: false
    };
    return Promise.resolve(emptyResponse);
  }
  const queryParams = {
    page_size: query.pageSize,
    page_number: query.pageNumber,
    include_orgs: query.includeOrgs,
    role: query.role
  };
  const queryString = formatQueryParameters(queryParams);
  return httpRequest(authUrl, integrationApiKey, `${ENDPOINT_PATH6}/org/${query.orgId}?${queryString}`, "GET").then(
    (httpResponse) => {
      if (httpResponse.statusCode === 401) {
        throw new Error("integrationApiKey is incorrect");
      } else if (httpResponse.statusCode === 429) {
        throw new RateLimitedException(httpResponse.response);
      } else if (httpResponse.statusCode === 400) {
        throw new Error("Invalid query " + httpResponse.response);
      } else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
        throw new Error("Unknown error when fetching users in org");
      }
      return parseSnakeCaseToCamelCase(httpResponse.response);
    }
  );
}
function fetchBatchUserMetadata(authUrl, integrationApiKey, type, values, keyFunction, includeOrgs) {
  const queryString = includeOrgs ? formatQueryParameters({ include_orgs: includeOrgs }) : "";
  const jsonBody = { [type]: values };
  return httpRequest(
    authUrl,
    integrationApiKey,
    `${ENDPOINT_PATH6}/${type}?${queryString}`,
    "POST",
    JSON.stringify(jsonBody)
  ).then((httpResponse) => {
    if (httpResponse.statusCode === 401) {
      throw new Error("integrationApiKey is incorrect");
    } else if (httpResponse.statusCode === 429) {
      throw new RateLimitedException(httpResponse.response);
    } else if (httpResponse.statusCode === 400) {
      throw new Error("Bad request " + httpResponse.response);
    } else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
      throw new Error("Unknown error when fetching batch user metadata");
    }
    const userMetadatas = parseSnakeCaseToCamelCase(httpResponse.response);
    const returnValue = {};
    for (let userMetadata of userMetadatas) {
      returnValue[keyFunction(userMetadata)] = userMetadata;
    }
    return returnValue;
  });
}
function createUser(authUrl, integrationApiKey, createUserRequest) {
  const request = {
    email: createUserRequest.email,
    email_confirmed: createUserRequest.emailConfirmed,
    send_email_to_confirm_email_address: createUserRequest.sendEmailToConfirmEmailAddress,
    password: createUserRequest.password,
    ask_user_to_update_password_on_login: createUserRequest.askUserToUpdatePasswordOnLogin,
    ignore_domain_restrictions: createUserRequest.ignoreDomainRestrictions,
    username: createUserRequest.username,
    first_name: createUserRequest.firstName,
    last_name: createUserRequest.lastName,
    properties: createUserRequest.properties
  };
  return httpRequest(authUrl, integrationApiKey, `${ENDPOINT_PATH6}/`, "POST", JSON.stringify(request)).then(
    (httpResponse) => {
      if (httpResponse.statusCode === 401) {
        throw new Error("integrationApiKey is incorrect");
      } else if (httpResponse.statusCode === 429) {
        throw new RateLimitedException(httpResponse.response);
      } else if (httpResponse.statusCode === 400) {
        throw new CreateUserException(httpResponse.response);
      } else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
        throw new Error("Unknown error when creating user");
      }
      return parseSnakeCaseToCamelCase(httpResponse.response);
    }
  );
}
function disableUser(authUrl, integrationApiKey, userId) {
  if (!isValidId(userId)) {
    return Promise.resolve(false);
  }
  return httpRequest(authUrl, integrationApiKey, `${ENDPOINT_PATH6}/${userId}/disable`, "POST").then(
    (httpResponse) => {
      if (httpResponse.statusCode === 401) {
        throw new Error("integrationApiKey is incorrect");
      } else if (httpResponse.statusCode === 429) {
        throw new RateLimitedException(httpResponse.response);
      } else if (httpResponse.statusCode === 404) {
        return false;
      } else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
        throw new Error("Unknown error when disabling user");
      }
      return true;
    }
  );
}
function enableUser(authUrl, integrationApiKey, userId) {
  if (!isValidId(userId)) {
    return Promise.resolve(false);
  }
  return httpRequest(authUrl, integrationApiKey, `${ENDPOINT_PATH6}/${userId}/enable`, "POST").then((httpResponse) => {
    if (httpResponse.statusCode === 401) {
      throw new Error("integrationApiKey is incorrect");
    } else if (httpResponse.statusCode === 429) {
      throw new RateLimitedException(httpResponse.response);
    } else if (httpResponse.statusCode === 404) {
      return false;
    } else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
      throw new Error("Unknown error when enabling user");
    }
    return true;
  });
}
function disableUser2fa(authUrl, integrationApiKey, userId) {
  if (!isValidId(userId)) {
    return Promise.resolve(false);
  }
  return httpRequest(authUrl, integrationApiKey, `${ENDPOINT_PATH6}/${userId}/disable_2fa`, "POST").then(
    (httpResponse) => {
      if (httpResponse.statusCode === 401) {
        throw new Error("integrationApiKey is incorrect");
      } else if (httpResponse.statusCode === 429) {
        throw new RateLimitedException(httpResponse.response);
      } else if (httpResponse.statusCode === 404) {
        return false;
      } else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
        throw new Error("Unknown error when disabling 2FA");
      }
      return true;
    }
  );
}
function resendEmailConfirmation(authUrl, integrationApiKey, userId) {
  if (!isValidId(userId)) {
    return Promise.resolve(false);
  }
  const request = {
    user_id: userId
  };
  return httpRequest(
    authUrl,
    integrationApiKey,
    "/api/backend/v1/resend_email_confirmation",
    "POST",
    JSON.stringify(request)
  ).then((httpResponse) => {
    if (httpResponse.statusCode === 401) {
      throw new Error("integrationApiKey is incorrect");
    } else if (httpResponse.statusCode === 404) {
      return false;
    } else if (httpResponse.statusCode === 429) {
      let errorMessage;
      try {
        errorMessage = JSON.parse(httpResponse.response).user_facing_error;
      } catch (SyntaxError) {
        errorMessage = httpResponse.response;
      }
      throw new RateLimitedException(errorMessage);
    } else if (httpResponse.statusCode === 400) {
      throw new BadRequestException(httpResponse.response);
    } else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
      throw new Error("Unknown error when resending email confirmation");
    }
    return true;
  });
}
function inviteUserToOrg(authUrl, integrationApiKey, inviteUserToOrgRequest) {
  var _a;
  const body = {
    org_id: inviteUserToOrgRequest.orgId,
    email: inviteUserToOrgRequest.email,
    role: inviteUserToOrgRequest.role,
    additional_roles: (_a = inviteUserToOrgRequest.additionalRoles) != null ? _a : []
  };
  return httpRequest(authUrl, integrationApiKey, `/api/backend/v1/invite_user`, "POST", JSON.stringify(body)).then(
    (httpResponse) => {
      if (httpResponse.statusCode === 401) {
        throw new Error("integrationApiKey is incorrect");
      } else if (httpResponse.statusCode === 429) {
        throw new RateLimitedException(httpResponse.response);
      } else if (httpResponse.statusCode === 400) {
        throw new BadRequestException(httpResponse.response);
      } else if (httpResponse.statusCode === 404) {
        return false;
      } else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
        throw new Error("Unknown error when inviting a user to the org");
      }
      return true;
    }
  );
}
function logoutAllUserSessions(authUrl, integrationApiKey, userId) {
  if (!isValidId(userId)) {
    return Promise.resolve(false);
  }
  return httpRequest(authUrl, integrationApiKey, `${ENDPOINT_PATH6}/${userId}/logout_all_sessions`, "POST").then(
    (httpResponse) => {
      if (httpResponse.statusCode === 401) {
        throw new Error("integrationApiKey is incorrect");
      } else if (httpResponse.statusCode === 429) {
        throw new RateLimitedException(httpResponse.response);
      } else if (httpResponse.statusCode === 404) {
        return false;
      } else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
        throw new Error("Unknown error when logging out all sessions");
      }
      return true;
    }
  );
}
function updateUserMetadata(authUrl, integrationApiKey, userId, updateUserMetadataRequest) {
  if (!isValidId(userId)) {
    return Promise.resolve(false);
  }
  const request = {
    username: updateUserMetadataRequest.username,
    first_name: updateUserMetadataRequest.firstName,
    last_name: updateUserMetadataRequest.lastName,
    picture_url: updateUserMetadataRequest.pictureUrl,
    metadata: updateUserMetadataRequest.metadata,
    properties: updateUserMetadataRequest.properties,
    update_password_required: updateUserMetadataRequest.updatePasswordRequired,
    legacy_user_id: updateUserMetadataRequest.legacyUserId
  };
  return httpRequest(authUrl, integrationApiKey, `${ENDPOINT_PATH6}/${userId}`, "PUT", JSON.stringify(request)).then(
    (httpResponse) => {
      if (httpResponse.statusCode === 401) {
        throw new Error("integrationApiKey is incorrect");
      } else if (httpResponse.statusCode === 429) {
        throw new RateLimitedException(httpResponse.response);
      } else if (httpResponse.statusCode === 400) {
        throw new UpdateUserMetadataException(httpResponse.response);
      } else if (httpResponse.statusCode === 404) {
        return false;
      } else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
        throw new Error("Unknown error when updating user metadata");
      }
      return true;
    }
  );
}
function updateUserEmail(authUrl, integrationApiKey, userId, updateUserEmail2) {
  if (!isValidId(userId)) {
    return Promise.resolve(false);
  }
  const request = {
    new_email: updateUserEmail2.newEmail,
    require_email_confirmation: updateUserEmail2.requireEmailConfirmation
  };
  return httpRequest(
    authUrl,
    integrationApiKey,
    `${ENDPOINT_PATH6}/${userId}/email`,
    "PUT",
    JSON.stringify(request)
  ).then((httpResponse) => {
    if (httpResponse.statusCode === 401) {
      throw new Error("integrationApiKey is incorrect");
    } else if (httpResponse.statusCode === 429) {
      throw new RateLimitedException(httpResponse.response);
    } else if (httpResponse.statusCode === 400) {
      throw new UpdateUserEmailException(httpResponse.response);
    } else if (httpResponse.statusCode === 404) {
      return false;
    } else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
      throw new Error("Unknown error when creating user");
    }
    return true;
  });
}
function updateUserPassword(authUrl, integrationApiKey, userId, updateUserPasswordRequest) {
  if (!isValidId(userId)) {
    return Promise.resolve(false);
  }
  const request = {
    password: updateUserPasswordRequest.password,
    ask_user_to_update_password_on_login: updateUserPasswordRequest.askUserToUpdatePasswordOnLogin
  };
  return httpRequest(
    authUrl,
    integrationApiKey,
    `${ENDPOINT_PATH6}/${userId}/password`,
    "PUT",
    JSON.stringify(request)
  ).then((httpResponse) => {
    if (httpResponse.statusCode === 401) {
      throw new Error("integrationApiKey is incorrect");
    } else if (httpResponse.statusCode === 429) {
      throw new RateLimitedException(httpResponse.response);
    } else if (httpResponse.statusCode === 400) {
      throw new UpdateUserPasswordException(httpResponse.response);
    } else if (httpResponse.statusCode === 404) {
      return false;
    } else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
      throw new Error("Unknown error when updating password");
    }
    return true;
  });
}
function enableUserCanCreateOrgs(authUrl, integrationApiKey, userId) {
  if (!isValidId(userId)) {
    return Promise.resolve(false);
  }
  return httpRequest(authUrl, integrationApiKey, `${ENDPOINT_PATH6}/${userId}/can_create_orgs/enable`, "PUT").then(
    (httpResponse) => {
      if (httpResponse.statusCode === 401) {
        throw new Error("integrationApiKey is incorrect");
      } else if (httpResponse.statusCode === 429) {
        throw new RateLimitedException(httpResponse.response);
      } else if (httpResponse.statusCode === 404) {
        return false;
      } else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
        throw new Error("Unknown error when enabling canCreateOrgs");
      }
      return true;
    }
  );
}
function disableUserCanCreateOrgs(authUrl, integrationApiKey, userId) {
  if (!isValidId(userId)) {
    return Promise.resolve(false);
  }
  return httpRequest(authUrl, integrationApiKey, `${ENDPOINT_PATH6}/${userId}/can_create_orgs/disable`, "PUT").then(
    (httpResponse) => {
      if (httpResponse.statusCode === 401) {
        throw new Error("integrationApiKey is incorrect");
      } else if (httpResponse.statusCode === 429) {
        throw new RateLimitedException(httpResponse.response);
      } else if (httpResponse.statusCode === 404) {
        return false;
      } else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
        throw new Error("Unknown error when disabling canCreateOrgs");
      }
      return true;
    }
  );
}
function clearUserPassword(authUrl, integrationApiKey, userId) {
  return __async(this, null, function* () {
    if (!isValidId(userId)) {
      return Promise.resolve(false);
    }
    const httpResponse = yield httpRequest(
      authUrl,
      integrationApiKey,
      `${ENDPOINT_PATH6}/${userId}/clear_password`,
      "PUT"
    );
    if (httpResponse.statusCode === 401) {
      throw new Error("integrationApiKey is incorrect");
    } else if (httpResponse.statusCode === 429) {
      throw new RateLimitedException(httpResponse.response);
    } else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
      throw new Error("Unknown error when clearing password");
    }
    return true;
  });
}
function deleteUser(authUrl, integrationApiKey, userId) {
  if (!isValidId(userId)) {
    return Promise.resolve(false);
  }
  return httpRequest(authUrl, integrationApiKey, `${ENDPOINT_PATH6}/${userId}`, "DELETE").then((httpResponse) => {
    if (httpResponse.statusCode === 401) {
      throw new Error("integrationApiKey is incorrect");
    } else if (httpResponse.statusCode === 429) {
      throw new RateLimitedException(httpResponse.response);
    } else if (httpResponse.statusCode === 404) {
      return false;
    } else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
      throw new Error("Unknown error when deleting user");
    }
    return true;
  });
}
function fetchUserSignupQueryParams(authUrl, integrationApiKey, userId) {
  return __async(this, null, function* () {
    if (!isValidId(userId)) {
      return Promise.resolve(null);
    }
    const httpResponse = yield httpRequest(
      authUrl,
      integrationApiKey,
      `${ENDPOINT_PATH6}/${userId}/signup_query_parameters`,
      "GET"
    );
    if (httpResponse.statusCode === 401) {
      throw new Error("integrationApiKey is incorrect");
    } else if (httpResponse.statusCode === 429) {
      throw new RateLimitedException(httpResponse.response);
    } else if (httpResponse.statusCode === 404) {
      return null;
    } else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
      throw new Error("Unknown error when fetching user signup query params");
    }
    const snakeCase = JSON.parse(httpResponse.response);
    return { userSignupQueryParameters: snakeCase["user_signup_query_parameters"] };
  });
}

// src/validators.ts
function validatePersonalApiKey(authUrl, integrationApiKey, apiKeyToken) {
  return __async(this, null, function* () {
    const apiKeyValidation = yield validateApiKey(authUrl, integrationApiKey, apiKeyToken);
    if (!apiKeyValidation.user || apiKeyValidation.org) {
      throw new ApiKeyValidateException(JSON.stringify({ api_key_token: ["Not a personal API Key"] }));
    }
    return {
      user: apiKeyValidation.user,
      metadata: apiKeyValidation.metadata
    };
  });
}
function validateOrgApiKey(authUrl, integrationApiKey, apiKeyToken) {
  return __async(this, null, function* () {
    const apiKeyValidation = yield validateApiKey(authUrl, integrationApiKey, apiKeyToken);
    if (!apiKeyValidation.org) {
      throw new ApiKeyValidateException(JSON.stringify({ api_key_token: ["Not an org API Key"] }));
    }
    return {
      org: apiKeyValidation.org,
      metadata: apiKeyValidation.metadata,
      user: apiKeyValidation.user,
      userInOrg: apiKeyValidation.userInOrg
    };
  });
}

// src/api.ts
function getApis(authUrl, integrationApiKey) {
  function fetchTokenVerificationMetadataWrapper() {
    return fetchTokenVerificationMetadata(authUrl, integrationApiKey);
  }
  function fetchUserMetadataByUserId(userId, includeOrgs) {
    return fetchUserMetadataByUserIdWithIdCheck(authUrl, integrationApiKey, userId, includeOrgs);
  }
  function fetchUserMetadataByEmail(email, includeOrgs) {
    return fetchUserMetadataByQuery(authUrl, integrationApiKey, "email", {
      email,
      include_orgs: includeOrgs || false
    });
  }
  function fetchUserMetadataByUsername(username, includeOrgs) {
    return fetchUserMetadataByQuery(authUrl, integrationApiKey, "username", {
      username,
      include_orgs: includeOrgs || false
    });
  }
  function fetchBatchUserMetadataByUserIds(userIds, includeOrgs) {
    return fetchBatchUserMetadata(
      authUrl,
      integrationApiKey,
      "user_ids",
      userIds,
      (x) => x.userId,
      includeOrgs || false
    );
  }
  function fetchBatchUserMetadataByEmails(emails, includeOrgs) {
    return fetchBatchUserMetadata(
      authUrl,
      integrationApiKey,
      "emails",
      emails,
      (x) => x.email,
      includeOrgs || false
    );
  }
  function fetchBatchUserMetadataByUsernames(usernames, includeOrgs) {
    return fetchBatchUserMetadata(
      authUrl,
      integrationApiKey,
      "usernames",
      usernames,
      (x) => x.username || "",
      includeOrgs || false
    );
  }
  function fetchOrgWrapper(orgId) {
    return fetchOrg(authUrl, integrationApiKey, orgId);
  }
  function fetchOrgsByQueryWrapper(orgQuery) {
    return fetchOrgByQuery(authUrl, integrationApiKey, orgQuery);
  }
  function fetchCustomRoleMappingsWrapper() {
    return fetchCustomRoleMappings(authUrl, integrationApiKey);
  }
  function fetchUsersByQueryWrapper(usersQuery) {
    return fetchUsersByQuery(authUrl, integrationApiKey, usersQuery);
  }
  function fetchUsersInOrgWrapper(usersInOrgQuery) {
    return fetchUsersInOrg(authUrl, integrationApiKey, usersInOrgQuery);
  }
  function fetchUserSignupQueryParamsWrapper(userId) {
    return fetchUserSignupQueryParams(authUrl, integrationApiKey, userId);
  }
  function createUserWrapper(createUserRequest) {
    return createUser(authUrl, integrationApiKey, createUserRequest);
  }
  function clearUserPasswordWrapper(userId) {
    return clearUserPassword(authUrl, integrationApiKey, userId);
  }
  function updateUserMetadataWrapper(userId, updateUserMetadataRequest) {
    return updateUserMetadata(authUrl, integrationApiKey, userId, updateUserMetadataRequest);
  }
  function deleteUserWrapper(userId) {
    return deleteUser(authUrl, integrationApiKey, userId);
  }
  function disableUserWrapper(userId) {
    return disableUser(authUrl, integrationApiKey, userId);
  }
  function enableUserWrapper(userId) {
    return enableUser(authUrl, integrationApiKey, userId);
  }
  function disableUser2faWrapper(userId) {
    return disableUser2fa(authUrl, integrationApiKey, userId);
  }
  function resendEmailConfirmationWrapper(userId) {
    return resendEmailConfirmation(authUrl, integrationApiKey, userId);
  }
  function updateUserEmailWrapper(userId, updateUserEmailRequest) {
    return updateUserEmail(authUrl, integrationApiKey, userId, updateUserEmailRequest);
  }
  function updateUserPasswordWrapper(userId, updateUserPasswordRequest) {
    return updateUserPassword(authUrl, integrationApiKey, userId, updateUserPasswordRequest);
  }
  function enableUserCanCreateOrgsWrapper(userId) {
    return enableUserCanCreateOrgs(authUrl, integrationApiKey, userId);
  }
  function disableUserCanCreateOrgsWrapper(userId) {
    return disableUserCanCreateOrgs(authUrl, integrationApiKey, userId);
  }
  function createMagicLinkWrapper(createMagicLinkRequest) {
    return createMagicLink(authUrl, integrationApiKey, createMagicLinkRequest);
  }
  function createAccessTokenWrapper(createAccessTokenRequest) {
    return createAccessToken(authUrl, integrationApiKey, createAccessTokenRequest);
  }
  function migrateUserFromExternalSourceWrapper(migrateUserFromExternalSourceRequest) {
    return migrateUserFromExternalSource(authUrl, integrationApiKey, migrateUserFromExternalSourceRequest);
  }
  function migrateUserPasswordWrapper(migrateUserPasswordRequest) {
    return migrateUserPassword(authUrl, integrationApiKey, migrateUserPasswordRequest);
  }
  function createOrgWrapper(createOrgRequest) {
    return createOrg(authUrl, integrationApiKey, createOrgRequest);
  }
  function addUserToOrgWrapper(addUserToOrgRequest) {
    return addUserToOrg(authUrl, integrationApiKey, addUserToOrgRequest);
  }
  function changeUserRoleInOrgWrapper(changeUserRoleInOrgRequest) {
    return changeUserRoleInOrg(authUrl, integrationApiKey, changeUserRoleInOrgRequest);
  }
  function removeUserFromOrgWrapper(removeUserFromOrgRequest) {
    return removeUserFromOrg(authUrl, integrationApiKey, removeUserFromOrgRequest);
  }
  function updateOrgWrapper(updateOrgRequest) {
    return updateOrg(authUrl, integrationApiKey, updateOrgRequest);
  }
  function subscribeOrgToRoleMappingWrapper(orgId, customRoleMappingName) {
    return subscribeOrgToRoleMapping(authUrl, integrationApiKey, orgId, customRoleMappingName);
  }
  function deleteOrgWrapper(orgId) {
    return deleteOrg(authUrl, integrationApiKey, orgId);
  }
  function allowOrgToSetupSamlConnectionWrapper(orgId) {
    return allowOrgToSetupSamlConnection(authUrl, integrationApiKey, orgId);
  }
  function disallowOrgToSetupSamlConnectionWrapper(orgId) {
    return disallowOrgToSetupSamlConnection(authUrl, integrationApiKey, orgId);
  }
  function createOrgSamlConnectionLinkWrapper(orgId, expiresInSeconds) {
    return createOrgSamlConnectionLink(authUrl, integrationApiKey, orgId, expiresInSeconds);
  }
  function fetchSamlSpMetadataWrapper(orgId) {
    return fetchSamlSpMetadata(authUrl, integrationApiKey, orgId);
  }
  function setSamlIdpMetadataWrapper(orgId, samlIdpMetadata) {
    return setSamlIdpMetadata(authUrl, integrationApiKey, orgId, samlIdpMetadata);
  }
  function samlGoLiveWrapper(orgId) {
    return samlGoLive(authUrl, integrationApiKey, orgId);
  }
  function deleteSamlConnectionWrapper(orgId) {
    return deleteSamlConnection(authUrl, integrationApiKey, orgId);
  }
  function inviteUserToOrgWrapper(inviteUserToOrgRequest) {
    return inviteUserToOrg(authUrl, integrationApiKey, inviteUserToOrgRequest);
  }
  function logoutAllUserSessionsWrapper(userId) {
    return logoutAllUserSessions(authUrl, integrationApiKey, userId);
  }
  function fetchPendingInvitesWrapper(params) {
    return fetchPendingInvites(authUrl, integrationApiKey, params);
  }
  function revokePendingOrgInviteWrapper(revokePendingOrgInviteRequest) {
    return revokePendingOrgInvite(authUrl, integrationApiKey, revokePendingOrgInviteRequest);
  }
  function fetchApiKeyWrapper(apiKeyId) {
    return fetchApiKey(authUrl, integrationApiKey, apiKeyId);
  }
  function fetchCurrentApiKeysWrapper(apiKeyQuery) {
    return fetchCurrentApiKeys(authUrl, integrationApiKey, apiKeyQuery);
  }
  function fetchArchivedApiKeysWrapper(apiKeyQuery) {
    return fetchArchivedApiKeys(authUrl, integrationApiKey, apiKeyQuery);
  }
  function createApiKeyWrapper(apiKeyCreate) {
    return createApiKey(authUrl, integrationApiKey, apiKeyCreate);
  }
  function updateApiKeyWrapper(apiKeyId, ApiKeyUpdate) {
    return updateApiKey(authUrl, integrationApiKey, apiKeyId, ApiKeyUpdate);
  }
  function deleteApiKeyWrapper(apiKeyId) {
    return deleteApiKey(authUrl, integrationApiKey, apiKeyId);
  }
  function validatePersonalApiKeyWrapper(apiKeyToken) {
    return validatePersonalApiKey(authUrl, integrationApiKey, apiKeyToken);
  }
  function validateOrgApiKeyWrapper(apiKeyToken) {
    return validateOrgApiKey(authUrl, integrationApiKey, apiKeyToken);
  }
  function validateApiKeyWrapper(apiKeyToken) {
    return validateApiKey(authUrl, integrationApiKey, apiKeyToken);
  }
  function verifyStepUpTotpChallengeWrapper(verifyTotpChallengeRequest) {
    return verifyStepUpTotpChallenge(authUrl, integrationApiKey, verifyTotpChallengeRequest);
  }
  function verifyStepUpGrantWrapper(verifyStepUpGrantRequest) {
    return verifyStepUpGrant(authUrl, integrationApiKey, verifyStepUpGrantRequest);
  }
  return {
    // fetching functions
    fetchTokenVerificationMetadata: fetchTokenVerificationMetadataWrapper,
    fetchUserMetadataByUserId,
    fetchUserMetadataByEmail,
    fetchUserMetadataByUsername,
    fetchBatchUserMetadataByUserIds,
    fetchBatchUserMetadataByEmails,
    fetchBatchUserMetadataByUsernames,
    fetchOrg: fetchOrgWrapper,
    fetchOrgByQuery: fetchOrgsByQueryWrapper,
    fetchCustomRoleMappings: fetchCustomRoleMappingsWrapper,
    fetchUsersByQuery: fetchUsersByQueryWrapper,
    fetchUsersInOrg: fetchUsersInOrgWrapper,
    fetchUserSignupQueryParams: fetchUserSignupQueryParamsWrapper,
    // user management functions
    createUser: createUserWrapper,
    updateUserMetadata: updateUserMetadataWrapper,
    updateUserEmail: updateUserEmailWrapper,
    updateUserPassword: updateUserPasswordWrapper,
    clearUserPassword: clearUserPasswordWrapper,
    createMagicLink: createMagicLinkWrapper,
    createAccessToken: createAccessTokenWrapper,
    migrateUserFromExternalSource: migrateUserFromExternalSourceWrapper,
    migrateUserPassword: migrateUserPasswordWrapper,
    deleteUser: deleteUserWrapper,
    disableUser: disableUserWrapper,
    enableUser: enableUserWrapper,
    disableUser2fa: disableUser2faWrapper,
    resendEmailConfirmation: resendEmailConfirmationWrapper,
    enableUserCanCreateOrgs: enableUserCanCreateOrgsWrapper,
    disableUserCanCreateOrgs: disableUserCanCreateOrgsWrapper,
    logoutAllUserSessions: logoutAllUserSessionsWrapper,
    // org management functions
    createOrg: createOrgWrapper,
    addUserToOrg: addUserToOrgWrapper,
    changeUserRoleInOrg: changeUserRoleInOrgWrapper,
    removeUserFromOrg: removeUserFromOrgWrapper,
    updateOrg: updateOrgWrapper,
    subscribeOrgToRoleMapping: subscribeOrgToRoleMappingWrapper,
    deleteOrg: deleteOrgWrapper,
    allowOrgToSetupSamlConnection: allowOrgToSetupSamlConnectionWrapper,
    disallowOrgToSetupSamlConnection: disallowOrgToSetupSamlConnectionWrapper,
    createOrgSamlConnectionLink: createOrgSamlConnectionLinkWrapper,
    inviteUserToOrg: inviteUserToOrgWrapper,
    fetchPendingInvites: fetchPendingInvitesWrapper,
    revokePendingOrgInvite: revokePendingOrgInviteWrapper,
    fetchSamlSpMetadata: fetchSamlSpMetadataWrapper,
    setSamlIdpMetadata: setSamlIdpMetadataWrapper,
    samlGoLive: samlGoLiveWrapper,
    deleteSamlConnection: deleteSamlConnectionWrapper,
    // api keys functions
    fetchApiKey: fetchApiKeyWrapper,
    fetchCurrentApiKeys: fetchCurrentApiKeysWrapper,
    fetchArchivedApiKeys: fetchArchivedApiKeysWrapper,
    createApiKey: createApiKeyWrapper,
    updateApiKey: updateApiKeyWrapper,
    deleteApiKey: deleteApiKeyWrapper,
    validateApiKey: validateApiKeyWrapper,
    validatePersonalApiKey: validatePersonalApiKeyWrapper,
    validateOrgApiKey: validateOrgApiKeyWrapper,
    // step-up mfa functions
    verifyStepUpTotpChallenge: verifyStepUpTotpChallengeWrapper,
    verifyStepUpGrant: verifyStepUpGrantWrapper
  };
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  AccessTokenCreationException,
  AddUserToOrgException,
  ApiKeyCreateException,
  ApiKeyDeleteException,
  ApiKeyFetchException,
  ApiKeyUpdateException,
  ApiKeyValidateException,
  ApiKeyValidateRateLimitedException,
  BadRequestException,
  ChangeUserRoleInOrgException,
  CreateOrgException,
  CreateUserException,
  FeatureGatedException,
  ForbiddenException,
  IncorrectMfaCodeException,
  InvalidRequestFieldsException,
  MagicLinkCreationException,
  MfaNotEnabledException,
  MigrateUserException,
  MigrateUserPasswordException,
  OrgMemberInfo,
  OrgRoleStructure,
  RateLimitedException,
  RemoveUserFromOrgException,
  RevokePendingOrgInviteException,
  UnauthorizedException,
  UnexpectedException,
  UpdateOrgException,
  UpdateUserEmailException,
  UpdateUserMetadataException,
  UpdateUserPasswordException,
  UserClass,
  UserNotFoundException,
  getApis,
  parseSnakeCaseToCamelCase,
  toOrgIdToOrgMemberInfo,
  toUser
});
//# sourceMappingURL=index.js.map