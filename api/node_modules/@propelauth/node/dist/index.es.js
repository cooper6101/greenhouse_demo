import { Buffer } from 'node:buffer';
import * as crypto from 'node:crypto';
import { KeyObject, createPublicKey, constants, createSecretKey } from 'node:crypto';
import * as util from 'node:util';
import { promisify } from 'node:util';

var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/exceptions.ts
var CreateUserException = class extends Error {
  constructor(message) {
    super(message);
    this.fieldToErrors = JSON.parse(message);
  }
};
var MigrateUserException = class extends Error {
  constructor(message) {
    super(message);
    this.fieldToErrors = JSON.parse(message);
  }
};
var MigrateUserPasswordException = class extends Error {
  constructor(message) {
    super(message);
    this.fieldToErrors = JSON.parse(message);
  }
};
var CreateOrgException = class extends Error {
  constructor(message) {
    super(message);
    this.fieldToErrors = JSON.parse(message);
  }
};
var AddUserToOrgException = class extends Error {
  constructor(message) {
    super(message);
    this.fieldToErrors = JSON.parse(message);
  }
};
var ChangeUserRoleInOrgException = class extends Error {
  constructor(message) {
    super(message);
    this.fieldToErrors = JSON.parse(message);
  }
};
var RemoveUserFromOrgException = class extends Error {
  constructor(message) {
    super(message);
    this.fieldToErrors = JSON.parse(message);
  }
};
var UpdateOrgException = class extends Error {
  constructor(message) {
    super(message);
    this.fieldToErrors = JSON.parse(message);
  }
};
var RevokePendingOrgInviteException = class extends Error {
  constructor(message) {
    super(message);
    this.fieldToErrors = JSON.parse(message);
  }
};
var ForbiddenException = class extends Error {
  constructor(message) {
    super(message);
    this.message = message;
    this.status = 403;
  }
};
var MagicLinkCreationException = class extends Error {
  constructor(message) {
    super(message);
    this.fieldToErrors = JSON.parse(message);
  }
};
var AccessTokenCreationException = class extends Error {
  constructor(message) {
    super(message);
    this.fieldToErrors = JSON.parse(message);
  }
};
var UnauthorizedException = class extends Error {
  constructor(message) {
    super(message);
    this.message = message;
    this.status = 401;
  }
};
var UnexpectedException = class extends Error {
  constructor(message) {
    super(message);
    this.message = message;
    this.status = 503;
  }
};
var UpdateUserEmailException = class extends Error {
  constructor(message) {
    super(message);
    this.fieldToErrors = JSON.parse(message);
  }
};
var UpdateUserPasswordException = class extends Error {
  constructor(message) {
    super(message);
    this.fieldToErrors = JSON.parse(message);
  }
};
var UpdateUserMetadataException = class extends Error {
  constructor(message) {
    super(message);
    this.fieldToErrors = JSON.parse(message);
  }
};
var UserNotFoundException = class extends Error {
};
var ApiKeyValidateException = class extends Error {
  constructor(message) {
    super(message);
    this.fieldToErrors = JSON.parse(message);
  }
};
var ApiKeyValidateRateLimitedException = class extends Error {
  constructor(errorBody) {
    super(errorBody);
    const parsedErrorBody = JSON.parse(errorBody);
    this.waitSeconds = parsedErrorBody.wait_seconds;
    this.userFacingError = parsedErrorBody.user_facing_error;
    this.errorCode = parsedErrorBody.error_code;
  }
};
var RateLimitedException = class extends Error {
  constructor(message) {
    super(message);
  }
};
var ApiKeyDeleteException = class extends Error {
  constructor(message) {
    super(message);
    this.fieldToErrors = JSON.parse(message);
  }
};
var ApiKeyUpdateException = class extends Error {
  constructor(message) {
    super(message);
    this.fieldToErrors = JSON.parse(message);
  }
};
var ApiKeyCreateException = class extends Error {
  constructor(message) {
    super(message);
    this.fieldToErrors = JSON.parse(message);
  }
};
var ApiKeyFetchException = class extends Error {
  constructor(message) {
    super(message);
    this.fieldToErrors = JSON.parse(message);
  }
};
var BadRequestException = class extends Error {
  constructor(message) {
    super(message);
    this.fieldToErrors = JSON.parse(message);
  }
};
var FeatureGatedException = class extends Error {
  constructor() {
    super("This feature isn't available on your current pricing plan");
  }
};
var IncorrectMfaCodeException = class extends Error {
};
var MfaNotEnabledException = class extends Error {
};
var InvalidRequestFieldsException = class extends Error {
  constructor(errorBody) {
    super("Invalid request");
    this.errorBody = JSON.parse(errorBody);
  }
};

// src/loginMethod.ts
function toLoginMethod(snake_case) {
  if (!snake_case) {
    return { loginMethod: "unknown" };
  }
  switch (snake_case.login_method) {
    case "password":
      return { loginMethod: "password" };
    case "magic_link":
      return { loginMethod: "magic_link" };
    case "social_sso":
      return { loginMethod: "social_sso", provider: snake_case.provider };
    case "email_confirmation_link":
      return { loginMethod: "email_confirmation_link" };
    case "saml_sso":
      return { loginMethod: "saml_sso", provider: snake_case.provider, orgId: snake_case.org_id };
    case "impersonation":
      return { loginMethod: "impersonation" };
    case "generated_from_backend_api":
      return { loginMethod: "generated_from_backend_api" };
    default:
      return { loginMethod: "unknown" };
  }
}

// src/user.ts
var UserClass = class _UserClass {
  constructor(user) {
    this.userId = user.userId;
    this.orgIdToUserOrgInfo = user.orgIdToOrgMemberInfo;
    this.email = user.email;
    this.firstName = user.firstName;
    this.lastName = user.lastName;
    this.username = user.username;
    this.legacyUserId = user.legacyUserId;
    this.impersonatorUserId = user.impersonatorUserId;
    this.properties = user.properties;
    this.loginMethod = user.loginMethod;
    this.activeOrgId = user.activeOrgId;
  }
  getActiveOrg() {
    if (!this.activeOrgId) {
      return void 0;
    }
    return this.getOrg(this.activeOrgId);
  }
  getActiveOrgId() {
    return this.activeOrgId;
  }
  getOrg(orgId) {
    if (!this.orgIdToUserOrgInfo) {
      return void 0;
    }
    if (!this.orgIdToUserOrgInfo.hasOwnProperty(orgId)) {
      return void 0;
    }
    return this.orgIdToUserOrgInfo[orgId];
  }
  getOrgByName(orgName) {
    if (!this.orgIdToUserOrgInfo) {
      return void 0;
    }
    const urlSafeOrgName = orgName.toLowerCase().replace(/ /g, "-");
    for (const orgId in this.orgIdToUserOrgInfo) {
      const orgMemberInfo = this.getOrg(orgId);
      if ((orgMemberInfo == null ? void 0 : orgMemberInfo.urlSafeOrgName) === urlSafeOrgName) {
        return orgMemberInfo;
      }
    }
    return void 0;
  }
  getUserProperty(key) {
    if (!this.properties || !this.properties.hasOwnProperty(key)) {
      return void 0;
    }
    return this.properties[key];
  }
  getOrgs() {
    if (!this.orgIdToUserOrgInfo) {
      return [];
    }
    return Object.values(this.orgIdToUserOrgInfo);
  }
  isImpersonating() {
    return !!this.impersonatorUserId;
  }
  isRole(orgId, role) {
    const orgMemberInfo = this.getOrg(orgId);
    if (!orgMemberInfo) {
      return false;
    }
    return orgMemberInfo.isRole(role);
  }
  isAtLeastRole(orgId, role) {
    const orgMemberInfo = this.getOrg(orgId);
    if (!orgMemberInfo) {
      return false;
    }
    return orgMemberInfo.isAtLeastRole(role);
  }
  hasPermission(orgId, permission) {
    const orgMemberInfo = this.getOrg(orgId);
    if (!orgMemberInfo) {
      return false;
    }
    return orgMemberInfo.hasPermission(permission);
  }
  hasAllPermissions(orgId, permissions) {
    const orgMemberInfo = this.getOrg(orgId);
    if (!orgMemberInfo) {
      return false;
    }
    return orgMemberInfo.hasAllPermissions(permissions);
  }
  static fromUser(user) {
    return new _UserClass(user);
  }
};
var OrgMemberInfo = class _OrgMemberInfo {
  constructor(orgId, orgName, orgMetadata, urlSafeOrgName, userAssignedRole, userInheritedRolesPlusCurrentRole, userPermissions, orgRoleStructure, userAssignedAdditionalRoles, legacyOrgId) {
    this.orgId = orgId;
    this.orgName = orgName;
    this.orgMetadata = orgMetadata;
    this.urlSafeOrgName = urlSafeOrgName;
    this.orgRoleStructure = orgRoleStructure != null ? orgRoleStructure : "single_role_in_hierarchy" /* SingleRole */;
    this.userAssignedRole = userAssignedRole;
    this.userInheritedRolesPlusCurrentRole = userInheritedRolesPlusCurrentRole;
    this.userPermissions = userPermissions;
    this.userAssignedAdditionalRoles = userAssignedAdditionalRoles != null ? userAssignedAdditionalRoles : [];
    this.legacyOrgId = legacyOrgId;
  }
  // getters
  get assignedRole() {
    return this.userAssignedRole;
  }
  get permissions() {
    return this.userPermissions;
  }
  get inheritedRolesPlusCurrentRole() {
    return this.userInheritedRolesPlusCurrentRole;
  }
  // validation methods
  isRole(role) {
    if (this.orgRoleStructure === "multi_role" /* MultiRole */) {
      return this.userAssignedRole === role || this.userAssignedAdditionalRoles.includes(role);
    } else {
      return this.userAssignedRole === role;
    }
  }
  isAtLeastRole(role) {
    if (this.orgRoleStructure === "multi_role" /* MultiRole */) {
      return this.userAssignedRole === role || this.userAssignedAdditionalRoles.includes(role);
    } else {
      return this.userInheritedRolesPlusCurrentRole.includes(role);
    }
  }
  hasPermission(permission) {
    return this.userPermissions.includes(permission);
  }
  hasAllPermissions(permissions) {
    return permissions.every((permission) => this.hasPermission(permission));
  }
  static fromJSON(json) {
    const obj = JSON.parse(json);
    try {
      return new _OrgMemberInfo(
        obj.orgId,
        obj.orgName,
        obj.orgMetadata,
        obj.urlSafeOrgName,
        obj.userAssignedRole,
        obj.userInheritedRolesPlusCurrentRole,
        obj.userPermissions,
        obj.orgRoleStructure,
        obj.userAssignedAdditionalRoles,
        obj.legacyOrgId
      );
    } catch (e) {
      console.error(
        "Unable to parse UserOrgInfo. Make sure the JSON string is a stringified `UserOrgInfo` type.",
        e
      );
      throw e;
    }
  }
};
function toUser(snake_case) {
  let orgIdToOrgMemberInfo;
  let activeOrgId;
  if (snake_case.org_member_info) {
    orgIdToOrgMemberInfo = toOrgIdToOrgMemberInfo({
      [snake_case.org_member_info.org_id]: snake_case.org_member_info
    });
    activeOrgId = snake_case.org_member_info.org_id;
  } else {
    orgIdToOrgMemberInfo = toOrgIdToOrgMemberInfo(snake_case.org_id_to_org_member_info);
    activeOrgId = void 0;
  }
  const camelCase2 = {
    userId: snake_case.user_id,
    orgIdToOrgMemberInfo,
    activeOrgId,
    email: snake_case.email,
    firstName: snake_case.first_name,
    lastName: snake_case.last_name,
    username: snake_case.username,
    legacyUserId: snake_case.legacy_user_id,
    impersonatorUserId: snake_case.impersonator_user_id,
    metadata: snake_case.metadata,
    properties: snake_case.properties,
    loginMethod: toLoginMethod(snake_case.login_method)
  };
  return camelCase2;
}
function toOrgIdToOrgMemberInfo(snake_case) {
  if (snake_case === void 0) {
    return void 0;
  }
  const camelCase2 = {};
  for (const key of Object.keys(snake_case)) {
    const snakeCaseValue = snake_case[key];
    if (snakeCaseValue) {
      camelCase2[key] = new OrgMemberInfo(
        snakeCaseValue.org_id,
        snakeCaseValue.org_name,
        snakeCaseValue.org_metadata,
        snakeCaseValue.url_safe_org_name,
        snakeCaseValue.user_role,
        snakeCaseValue.inherited_user_roles_plus_current_role,
        snakeCaseValue.user_permissions,
        snakeCaseValue.org_role_structure,
        snakeCaseValue.additional_roles,
        snakeCaseValue.legacy_org_id
      );
    }
  }
  return camelCase2;
}

// src/http.ts
var BACKEND_API_BASE_URL = "https://propelauth-api.com";
function httpRequest(authUrl, apiKey, path, method, body) {
  let headers = {
    Authorization: "Bearer " + apiKey,
    "Content-Type": "application/json",
    "X-Propelauth-url": authUrl.hostname
  };
  return fetch(BACKEND_API_BASE_URL + path, {
    method,
    headers,
    body
  }).then((response) => {
    return response.text().then((res) => {
      return {
        statusCode: response.status,
        response: res
      };
    });
  });
}

// src/utils.ts
var idRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
var hexRegex = /^[0-9a-fA-F]{32}$/i;
function isValidId(id) {
  return idRegex.test(id);
}
function isValidHex(id) {
  return hexRegex.test(id);
}
function removeBearerIfExists(token) {
  if (!token) {
    return token;
  } else if (token.toLowerCase().startsWith("bearer ")) {
    return token.substring(7);
  } else {
    return token;
  }
}
function formatQueryParameters(obj) {
  const params = new URLSearchParams();
  for (const [key, value] of Object.entries(obj)) {
    if (value !== void 0) {
      params.set(key, value);
    }
  }
  return params.toString();
}
function parseSnakeCaseToCamelCase(response) {
  let parsedObject = JSON.parse(response);
  return processKeys(parsedObject);
}
var keysForValueNotToModify = ["metadata", "org_metadata"];
function isOrgMemberInfo(value) {
  return value && typeof value === "object" && value.hasOwnProperty("orgId") && value.hasOwnProperty("orgName") && value.hasOwnProperty("urlSafeOrgName") && value.hasOwnProperty("orgMetadata") && value.hasOwnProperty("userAssignedRole") && value.hasOwnProperty("userInheritedRolesPlusCurrentRole") && value.hasOwnProperty("userPermissions");
}
function processKeys(obj) {
  let newObj = Array.isArray(obj) ? [] : {};
  for (let key in obj) {
    if (!obj.hasOwnProperty(key)) {
      continue;
    }
    let value = obj[key];
    const doNotModifyValue = keysForValueNotToModify.includes(key);
    if (!doNotModifyValue && value && typeof value === "object") {
      value = processKeys(value);
    }
    if (isOrgMemberInfo(value)) {
      value = new OrgMemberInfo(
        value["orgId"],
        value["orgName"],
        value["orgMetadata"],
        value["urlSafeOrgName"],
        value["userAssignedRole"],
        value["userInheritedRolesPlusCurrentRole"],
        value["userPermissions"],
        value["orgRoleStructure"],
        value["userAssignedAdditionalRoles"],
        value["legacyOrgId"]
      );
    }
    let newKey;
    if (key === "user_role") {
      newKey = "userAssignedRole";
    } else if (key === "inherited_user_roles_plus_current_role") {
      newKey = "userInheritedRolesPlusCurrentRole";
    } else if (key === "additional_roles") {
      newKey = "userAssignedAdditionalRoles";
    } else {
      newKey = camelCase(key);
    }
    newObj[newKey] = value;
  }
  return newObj;
}
function camelCase(key) {
  return key.replace(/_([a-z])/g, function(g) {
    return g[1].toUpperCase();
  });
}

// src/api/accessToken.ts
var ENDPOINT_PATH = "/api/backend/v1/access_token";
function createAccessToken(authUrl, integrationApiKey, createAccessTokenRequest) {
  if (!isValidId(createAccessTokenRequest.userId)) {
    throw new UserNotFoundException();
  }
  const request = {
    user_id: createAccessTokenRequest.userId,
    duration_in_minutes: createAccessTokenRequest.durationInMinutes,
    active_org_id: createAccessTokenRequest.activeOrgId
  };
  return httpRequest(authUrl, integrationApiKey, ENDPOINT_PATH, "POST", JSON.stringify(request)).then(
    (httpResponse) => {
      if (httpResponse.statusCode === 401) {
        throw new Error("integrationApiKey is incorrect");
      } else if (httpResponse.statusCode === 429) {
        throw new RateLimitedException(httpResponse.response);
      } else if (httpResponse.statusCode === 400) {
        throw new AccessTokenCreationException(httpResponse.response);
      } else if (httpResponse.statusCode === 403) {
        throw new UserNotFoundException();
      } else if (httpResponse.statusCode === 404) {
        throw new Error("Access token creation is not enabled");
      } else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
        throw new Error("Unknown error when creating access token");
      }
      return JSON.parse(httpResponse.response);
    }
  );
}

// src/api/endUserApiKeys.ts
var ENDPOINT_PATH2 = "/api/backend/v1/end_user_api_keys";
function fetchApiKey(authUrl, integrationApiKey, apiKeyId) {
  if (!isValidHex(apiKeyId)) {
    throw new ApiKeyFetchException("Invalid api key");
  }
  return httpRequest(authUrl, integrationApiKey, `${ENDPOINT_PATH2}/${apiKeyId}`, "GET").then((httpResponse) => {
    if (httpResponse.statusCode === 401) {
      throw new Error("integrationApiKey is incorrect");
    } else if (httpResponse.statusCode === 429) {
      throw new RateLimitedException(httpResponse.response);
    } else if (httpResponse.statusCode === 400) {
      throw new ApiKeyFetchException(httpResponse.response);
    } else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
      throw new Error("Unknown error when creating the end user api key");
    }
    return parseSnakeCaseToCamelCase(httpResponse.response);
  });
}
function fetchCurrentApiKeys(authUrl, integrationApiKey, apiKeyQuery) {
  const request = {
    org_id: apiKeyQuery.orgId,
    user_id: apiKeyQuery.userId,
    user_email: apiKeyQuery.userEmail,
    page_size: apiKeyQuery.pageSize,
    page_number: apiKeyQuery.pageNumber
  };
  const queryString = formatQueryParameters(request);
  return httpRequest(authUrl, integrationApiKey, `${ENDPOINT_PATH2}?${queryString}`, "GET").then((httpResponse) => {
    if (httpResponse.statusCode === 401) {
      throw new Error("integrationApiKey is incorrect");
    } else if (httpResponse.statusCode === 429) {
      throw new RateLimitedException(httpResponse.response);
    } else if (httpResponse.statusCode === 400) {
      throw new ApiKeyFetchException(httpResponse.response);
    } else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
      throw new Error("Unknown error when creating the end user api key");
    }
    return parseSnakeCaseToCamelCase(httpResponse.response);
  });
}
function fetchArchivedApiKeys(authUrl, integrationApiKey, apiKeyQuery) {
  const request = {
    org_id: apiKeyQuery.orgId,
    user_id: apiKeyQuery.userId,
    user_email: apiKeyQuery.userEmail,
    page_size: apiKeyQuery.pageSize,
    page_number: apiKeyQuery.pageNumber
  };
  const queryString = formatQueryParameters(request);
  return httpRequest(authUrl, integrationApiKey, `${ENDPOINT_PATH2}/archived?${queryString}`, "GET").then(
    (httpResponse) => {
      if (httpResponse.statusCode === 401) {
        throw new Error("integrationApiKey is incorrect");
      } else if (httpResponse.statusCode === 429) {
        throw new RateLimitedException(httpResponse.response);
      } else if (httpResponse.statusCode === 400) {
        throw new ApiKeyFetchException(httpResponse.response);
      } else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
        throw new Error("Unknown error when creating the end user api key");
      }
      return parseSnakeCaseToCamelCase(httpResponse.response);
    }
  );
}
function createApiKey(authUrl, integrationApiKey, apiKeyCreate) {
  const request = {
    org_id: apiKeyCreate.orgId,
    user_id: apiKeyCreate.userId,
    expires_at_seconds: apiKeyCreate.expiresAtSeconds,
    metadata: apiKeyCreate.metadata
  };
  return httpRequest(authUrl, integrationApiKey, `${ENDPOINT_PATH2}`, "POST", JSON.stringify(request)).then(
    (httpResponse) => {
      if (httpResponse.statusCode === 401) {
        throw new Error("integrationApiKey is incorrect");
      } else if (httpResponse.statusCode === 429) {
        throw new RateLimitedException(httpResponse.response);
      } else if (httpResponse.statusCode === 400) {
        throw new ApiKeyCreateException(httpResponse.response);
      } else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
        throw new Error("Unknown error when creating the end user api key");
      }
      return parseSnakeCaseToCamelCase(httpResponse.response);
    }
  );
}
function validateApiKey(authUrl, integrationApiKey, apiKeyToken) {
  const request = {
    api_key_token: removeBearerIfExists(apiKeyToken)
  };
  return httpRequest(authUrl, integrationApiKey, `${ENDPOINT_PATH2}/validate`, "POST", JSON.stringify(request)).then(
    (httpResponse) => {
      if (httpResponse.statusCode === 401) {
        throw new Error("integrationApiKey is incorrect");
      } else if (httpResponse.statusCode === 400) {
        throw new ApiKeyValidateException(httpResponse.response);
      } else if (httpResponse.statusCode === 429) {
        let rateLimitError;
        try {
          rateLimitError = new ApiKeyValidateRateLimitedException(httpResponse.response);
        } catch (SyntaxError) {
          throw new RateLimitedException(httpResponse.response);
        }
        throw rateLimitError;
      } else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
        throw new Error("Unknown error when updating the end user api key");
      }
      return parseSnakeCaseToCamelCase(httpResponse.response);
    }
  );
}
function updateApiKey(authUrl, integrationApiKey, apiKeyId, apiKeyUpdate) {
  if (!isValidHex(apiKeyId)) {
    throw new ApiKeyUpdateException("Invalid api key");
  }
  const request = {
    expires_at_seconds: apiKeyUpdate.expiresAtSeconds,
    metadata: apiKeyUpdate.metadata
  };
  return httpRequest(
    authUrl,
    integrationApiKey,
    `${ENDPOINT_PATH2}/${apiKeyId}`,
    "PATCH",
    JSON.stringify(request)
  ).then((httpResponse) => {
    if (httpResponse.statusCode === 401) {
      throw new Error("integrationApiKey is incorrect");
    } else if (httpResponse.statusCode === 429) {
      throw new RateLimitedException(httpResponse.response);
    } else if (httpResponse.statusCode === 400) {
      throw new ApiKeyUpdateException(httpResponse.response);
    } else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
      throw new Error("Unknown error when updating the end user api key");
    }
    return true;
  });
}
function deleteApiKey(authUrl, integrationApiKey, apiKeyId) {
  if (!isValidHex(apiKeyId)) {
    throw new ApiKeyDeleteException("Invalid api key");
  }
  return httpRequest(authUrl, integrationApiKey, `${ENDPOINT_PATH2}/${apiKeyId}`, "DELETE").then((httpResponse) => {
    if (httpResponse.statusCode === 401) {
      throw new Error("integrationApiKey is incorrect");
    } else if (httpResponse.statusCode === 429) {
      throw new RateLimitedException(httpResponse.response);
    } else if (httpResponse.statusCode === 400) {
      throw new ApiKeyDeleteException(httpResponse.response);
    } else if (httpResponse.statusCode === 404) {
      return false;
    } else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
      throw new Error("Unknown error when deleting the end user api key");
    }
    return true;
  });
}

// src/api/mfa/verifyTotp.ts
var STEP_UP_VERIFY_TOTP_ENDPOINT_PATH = "/api/backend/v1/mfa/step-up/verify-totp";
function verifyStepUpTotpChallenge(authUrl, integrationApiKey, verifyTotpChallengeRequest) {
  const request = {
    action_type: verifyTotpChallengeRequest.actionType,
    user_id: verifyTotpChallengeRequest.userId,
    code: verifyTotpChallengeRequest.code,
    grant_type: verifyTotpChallengeRequest.grantType,
    valid_for_seconds: verifyTotpChallengeRequest.validForSeconds
  };
  return httpRequest(
    authUrl,
    integrationApiKey,
    STEP_UP_VERIFY_TOTP_ENDPOINT_PATH,
    "POST",
    JSON.stringify(request)
  ).then((httpResponse) => {
    if (httpResponse.statusCode && httpResponse.statusCode < 400) {
      const responseData = JSON.parse(httpResponse.response);
      return {
        stepUpGrant: responseData.step_up_grant
      };
    }
    const errorResponse = httpResponse.response ? JSON.parse(httpResponse.response) : {};
    if (httpResponse.statusCode === 401) {
      throw new UnauthorizedException("integrationApiKey is incorrect");
    } else if (errorResponse.error_code === "user_not_found") {
      throw new UserNotFoundException();
    } else if (errorResponse.error_code === "mfa_not_enabled") {
      throw new MfaNotEnabledException();
    } else if (errorResponse.error_code === "incorrect_mfa_code") {
      throw new IncorrectMfaCodeException();
    } else if (errorResponse.error_code === "invalid_request_fields") {
      throw new InvalidRequestFieldsException(httpResponse.response);
    } else if (errorResponse.error_code === "feature_gated") {
      throw new FeatureGatedException();
    } else {
      throw new UnexpectedException("Unknown error when verifying the TOTP challenge");
    }
  });
}

// src/api/mfa/verifyGrant.ts
var STEP_UP_VERIFY_GRANT_ENDPOINT_PATH = "/api/backend/v1/mfa/step-up/verify-grant";
function verifyStepUpGrant(authUrl, integrationApiKey, verifyStepUpGrantRequest) {
  const request = {
    action_type: verifyStepUpGrantRequest.actionType,
    user_id: verifyStepUpGrantRequest.userId,
    grant: verifyStepUpGrantRequest.grant
  };
  return httpRequest(
    authUrl,
    integrationApiKey,
    STEP_UP_VERIFY_GRANT_ENDPOINT_PATH,
    "POST",
    JSON.stringify(request)
  ).then((httpResponse) => {
    if (httpResponse.statusCode && httpResponse.statusCode < 400) {
      return {
        success: true
      };
    }
    let errorResponse = {};
    try {
      errorResponse = httpResponse.response ? JSON.parse(httpResponse.response) : {};
    } catch (e) {
      console.error("Failed to parse error response", e);
      errorResponse = {};
    }
    if (httpResponse.statusCode === 401 || errorResponse.error_code === "unauthorized") {
      throw new UnauthorizedException("integrationApiKey is incorrect");
    } else if (httpResponse.statusCode === 429) {
      throw new RateLimitedException(httpResponse.response);
    } else if (errorResponse.error_code === "invalid_request_fields") {
      const fieldToErrors = errorResponse.field_errors || {};
      if (fieldToErrors["grant"] == "grant_not_found") {
        return {
          success: false
        };
      } else {
        throw new BadRequestException(httpResponse.response);
      }
    } else if (errorResponse.error_code === "feature_gated") {
      throw new FeatureGatedException();
    } else {
      throw new UnexpectedException("Unknown error when verifying step up grant");
    }
  });
}

// src/api/magicLink.ts
var ENDPOINT_PATH3 = "/api/backend/v1/magic_link";
function createMagicLink(authUrl, integrationApiKey, createMagicLinkRequest) {
  const request = {
    email: createMagicLinkRequest.email,
    redirect_to_url: createMagicLinkRequest.redirectToUrl,
    expires_in_hours: createMagicLinkRequest.expiresInHours,
    create_new_user_if_one_doesnt_exist: createMagicLinkRequest.createNewUserIfOneDoesntExist
  };
  return httpRequest(authUrl, integrationApiKey, ENDPOINT_PATH3, "POST", JSON.stringify(request)).then(
    (httpResponse) => {
      if (httpResponse.statusCode === 401) {
        throw new Error("integrationApiKey is incorrect");
      } else if (httpResponse.statusCode === 429) {
        throw new RateLimitedException(httpResponse.response);
      } else if (httpResponse.statusCode === 400) {
        throw new MagicLinkCreationException(httpResponse.response);
      } else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
        throw new Error("Unknown error when creating magic link");
      }
      return JSON.parse(httpResponse.response);
    }
  );
}

// src/api/migrateUser.ts
var ENDPOINT_PATH4 = "/api/backend/v1/migrate_user";
function migrateUserFromExternalSource(authUrl, integrationApiKey, migrateUserFromExternalSourceRequest) {
  const {
    email,
    emailConfirmed: email_confirmed,
    existingUserId: existing_user_id,
    existingPasswordHash: existing_password_hash,
    existingMfaBase32EncodedSecret: existing_mfa_base32_encoded_secret,
    askUserToUpdatePasswordOnLogin: update_password_required,
    enabled,
    firstName: first_name,
    lastName: last_name,
    username,
    pictureUrl: picture_url,
    properties
  } = migrateUserFromExternalSourceRequest;
  const request = {
    email,
    email_confirmed,
    existing_user_id,
    existing_password_hash,
    existing_mfa_base32_encoded_secret,
    update_password_required,
    enabled,
    first_name,
    last_name,
    username,
    picture_url,
    properties
  };
  return httpRequest(authUrl, integrationApiKey, `${ENDPOINT_PATH4}/`, "POST", JSON.stringify(request)).then(
    (httpResponse) => {
      if (httpResponse.statusCode === 401) {
        throw new Error("integrationApiKey is incorrect");
      } else if (httpResponse.statusCode === 429) {
        throw new RateLimitedException(httpResponse.response);
      } else if (httpResponse.statusCode === 400) {
        throw new MigrateUserException(httpResponse.response);
      } else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
        throw new Error("Unknown error when migrating user");
      }
      return parseSnakeCaseToCamelCase(httpResponse.response);
    }
  );
}
function migrateUserPassword(authUrl, integrationApiKey, migrateUserPasswordRequest) {
  if (!isValidId(migrateUserPasswordRequest.userId)) {
    return Promise.resolve(false);
  }
  const request = {
    user_id: migrateUserPasswordRequest.userId,
    password_hash: migrateUserPasswordRequest.passwordHash
  };
  return httpRequest(authUrl, integrationApiKey, `${ENDPOINT_PATH4}/password`, "POST", JSON.stringify(request)).then(
    (httpResponse) => {
      if (httpResponse.statusCode === 401) {
        throw new Error("integrationApiKey is incorrect");
      } else if (httpResponse.statusCode === 429) {
        throw new RateLimitedException(httpResponse.response);
      } else if (httpResponse.statusCode === 400) {
        throw new MigrateUserPasswordException(httpResponse.response);
      } else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
        throw new Error("Unknown error when migrating user password");
      }
      return parseSnakeCaseToCamelCase(httpResponse.response);
    }
  );
}

// src/api/org.ts
var BASE_ENDPOINT_PATH = "/api/backend/v1";
var ORG_ENDPOINT_PATH = BASE_ENDPOINT_PATH + "/org";
function fetchOrg(authUrl, integrationApiKey, orgId) {
  if (!isValidId(orgId)) {
    return Promise.resolve(null);
  }
  return httpRequest(authUrl, integrationApiKey, `${ORG_ENDPOINT_PATH}/${orgId}`, "GET").then((httpResponse) => {
    if (httpResponse.statusCode === 401) {
      throw new Error("integrationApiKey is incorrect");
    } else if (httpResponse.statusCode === 429) {
      throw new RateLimitedException(httpResponse.response);
    } else if (httpResponse.statusCode === 404) {
      return null;
    } else if (httpResponse.statusCode === 426) {
      throw new Error(
        "Cannot use organizations unless B2B support is enabled. Enable it in your PropelAuth dashboard."
      );
    } else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
      throw new Error("Unknown error when fetching org");
    }
    return parseSnakeCaseToCamelCase(httpResponse.response);
  });
}
function fetchCustomRoleMappings(authUrl, integrationApiKey) {
  return httpRequest(authUrl, integrationApiKey, "/api/backend/v1/custom_role_mappings", "GET").then(
    (httpResponse) => {
      if (httpResponse.statusCode === 401) {
        throw new Error("integrationApiKey is incorrect");
      } else if (httpResponse.statusCode === 429) {
        throw new RateLimitedException(httpResponse.response);
      } else if (httpResponse.statusCode === 426) {
        throw new Error(
          "Cannot use organizations unless B2B support is enabled. Enable it in your PropelAuth dashboard."
        );
      } else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
        throw new Error("Unknown error when fetching custom role mappings");
      }
      return parseSnakeCaseToCamelCase(httpResponse.response);
    }
  );
}
function fetchPendingInvites(authUrl, integrationApiKey, params) {
  const queryParams = new URLSearchParams();
  if (params == null ? void 0 : params.orgId) {
    queryParams.set("org_id", params.orgId);
  }
  if (params == null ? void 0 : params.pageSize) {
    queryParams.set("page_size", params.pageSize.toString());
  }
  if (params == null ? void 0 : params.pageNumber) {
    queryParams.set("page_number", params.pageNumber.toString());
  }
  const path = `/api/backend/v1/pending_org_invites?${queryParams.toString()}`;
  return httpRequest(authUrl, integrationApiKey, path, "GET").then((httpResponse) => {
    if (httpResponse.statusCode === 401) {
      throw new Error("integrationApiKey is incorrect");
    } else if (httpResponse.statusCode === 429) {
      throw new RateLimitedException(httpResponse.response);
    } else if (httpResponse.statusCode === 426) {
      throw new Error(
        "Cannot use organizations unless B2B support is enabled. Enable it in your PropelAuth dashboard."
      );
    } else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
      throw new Error("Unknown error when fetching pending invites");
    }
    return parseSnakeCaseToCamelCase(httpResponse.response);
  });
}
function fetchSamlSpMetadata(authUrl, integrationApiKey, orgId) {
  const path = BASE_ENDPOINT_PATH + `/saml_sp_metadata/${orgId}`;
  return httpRequest(authUrl, integrationApiKey, path, "GET").then((httpResponse) => {
    if (httpResponse.statusCode === 401) {
      throw new Error("integrationApiKey is incorrect");
    } else if (httpResponse.statusCode === 429) {
      throw new RateLimitedException(httpResponse.response);
    } else if (httpResponse.statusCode === 426) {
      throw new Error(
        "Cannot use organizations unless B2B support is enabled. Enable it in your PropelAuth dashboard."
      );
    } else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
      throw new Error("Unknown error when fetching custom role mappings");
    }
    return parseSnakeCaseToCamelCase(httpResponse.response);
  });
}
function fetchOrgByQuery(authUrl, integrationApiKey, query) {
  const request = {
    page_size: query.pageSize,
    page_number: query.pageNumber,
    order_by: query.orderBy,
    name: query.name,
    legacy_org_id: query.legacyOrgId,
    domain: query.domain
  };
  return httpRequest(authUrl, integrationApiKey, `${ORG_ENDPOINT_PATH}/query`, "POST", JSON.stringify(request)).then(
    (httpResponse) => {
      if (httpResponse.statusCode === 401) {
        throw new Error("integrationApiKey is incorrect");
      } else if (httpResponse.statusCode === 429) {
        throw new RateLimitedException(httpResponse.response);
      } else if (httpResponse.statusCode === 400) {
        throw new Error("Invalid query " + httpResponse.response);
      } else if (httpResponse.statusCode === 426) {
        throw new Error(
          "Cannot use organizations unless B2B support is enabled. Enable it in your PropelAuth dashboard."
        );
      } else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
        throw new Error("Unknown error when fetching orgs by query");
      }
      return JSON.parse(httpResponse.response, function(key, value) {
        if (key === "org_id") {
          this.orgId = value;
        } else if (key === "org_name") {
          this.name = value;
        } else if (key === "max_users") {
          this.maxUsers = value;
        } else if (key === "legacy_org_id") {
          this.legacyOrgId = value;
        } else if (key === "total_orgs") {
          this.totalOrgs = value;
        } else if (key === "current_page") {
          this.currentPage = value;
        } else if (key === "page_size") {
          this.pageSize = value;
        } else if (key === "has_more_results") {
          this.hasMoreResults = value;
        } else {
          return value;
        }
      });
    }
  );
}
function createOrg(authUrl, integrationApiKey, createOrgRequest) {
  const {
    name,
    domain,
    enableAutoJoiningByDomain = false,
    membersMustHaveMatchingDomain = false,
    maxUsers,
    customRoleMappingName,
    legacyOrgId
  } = createOrgRequest;
  const request = {
    name,
    enable_auto_joining_by_domain: enableAutoJoiningByDomain,
    members_must_have_matching_domain: membersMustHaveMatchingDomain
  };
  if (domain) {
    request["domain"] = domain;
  }
  if (maxUsers) {
    request["max_users"] = maxUsers;
  }
  if (legacyOrgId) {
    request["legacy_org_id"] = legacyOrgId;
  }
  if (customRoleMappingName) {
    request["custom_role_mapping_name"] = customRoleMappingName;
  }
  return httpRequest(authUrl, integrationApiKey, `${ORG_ENDPOINT_PATH}/`, "POST", JSON.stringify(request)).then(
    (httpResponse) => {
      if (httpResponse.statusCode === 401) {
        throw new Error("integrationApiKey is incorrect");
      } else if (httpResponse.statusCode === 429) {
        throw new RateLimitedException(httpResponse.response);
      } else if (httpResponse.statusCode === 400) {
        throw new CreateOrgException(httpResponse.response);
      } else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
        throw new Error("Unknown error when creating org");
      }
      return parseSnakeCaseToCamelCase(httpResponse.response);
    }
  );
}
function addUserToOrg(authUrl, integrationApiKey, addUserToOrgRequest) {
  var _a;
  const request = {
    user_id: addUserToOrgRequest.userId,
    org_id: addUserToOrgRequest.orgId,
    role: addUserToOrgRequest.role,
    additional_roles: (_a = addUserToOrgRequest.additionalRoles) != null ? _a : []
  };
  return httpRequest(authUrl, integrationApiKey, `${ORG_ENDPOINT_PATH}/add_user`, "POST", JSON.stringify(request)).then(
    (httpResponse) => {
      if (httpResponse.statusCode === 401) {
        throw new Error("integrationApiKey is incorrect");
      } else if (httpResponse.statusCode === 429) {
        throw new RateLimitedException(httpResponse.response);
      } else if (httpResponse.statusCode === 400) {
        throw new AddUserToOrgException(httpResponse.response);
      } else if (httpResponse.statusCode === 404) {
        return false;
      } else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
        throw new Error("Unknown error when adding user to org");
      }
      return true;
    }
  );
}
function changeUserRoleInOrg(authUrl, integrationApiKey, changeUserRoleInOrgRequest) {
  var _a;
  const request = {
    user_id: changeUserRoleInOrgRequest.userId,
    org_id: changeUserRoleInOrgRequest.orgId,
    role: changeUserRoleInOrgRequest.role,
    additional_roles: (_a = changeUserRoleInOrgRequest.additionalRoles) != null ? _a : []
  };
  return httpRequest(
    authUrl,
    integrationApiKey,
    `${ORG_ENDPOINT_PATH}/change_role`,
    "POST",
    JSON.stringify(request)
  ).then((httpResponse) => {
    if (httpResponse.statusCode === 401) {
      throw new Error("integrationApiKey is incorrect");
    } else if (httpResponse.statusCode === 429) {
      throw new RateLimitedException(httpResponse.response);
    } else if (httpResponse.statusCode === 400) {
      throw new ChangeUserRoleInOrgException(httpResponse.response);
    } else if (httpResponse.statusCode === 404) {
      return false;
    } else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
      throw new Error("Unknown error when changing users role in org");
    }
    return true;
  });
}
function removeUserFromOrg(authUrl, integrationApiKey, removeUserFromOrgRequest) {
  const request = {
    user_id: removeUserFromOrgRequest.userId,
    org_id: removeUserFromOrgRequest.orgId
  };
  return httpRequest(
    authUrl,
    integrationApiKey,
    `${ORG_ENDPOINT_PATH}/remove_user`,
    "POST",
    JSON.stringify(request)
  ).then((httpResponse) => {
    if (httpResponse.statusCode === 401) {
      throw new Error("integrationApiKey is incorrect");
    } else if (httpResponse.statusCode === 429) {
      throw new RateLimitedException(httpResponse.response);
    } else if (httpResponse.statusCode === 400) {
      throw new RemoveUserFromOrgException(httpResponse.response);
    } else if (httpResponse.statusCode === 404) {
      return false;
    } else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
      throw new Error("Unknown error when removing users from org");
    }
    return true;
  });
}
function allowOrgToSetupSamlConnection(authUrl, integrationApiKey, orgId) {
  if (!isValidId(orgId)) {
    return Promise.resolve(false);
  }
  return httpRequest(authUrl, integrationApiKey, `${ORG_ENDPOINT_PATH}/${orgId}/allow_saml`, "POST").then(
    (httpResponse) => {
      if (httpResponse.statusCode === 401) {
        throw new Error("integrationApiKey is incorrect");
      } else if (httpResponse.statusCode === 429) {
        throw new RateLimitedException(httpResponse.response);
      } else if (httpResponse.statusCode === 404) {
        return false;
      } else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
        throw new Error("Unknown error when allowing org to setup SAML connection");
      }
      return true;
    }
  );
}
function disallowOrgToSetupSamlConnection(authUrl, integrationApiKey, orgId) {
  if (!isValidId(orgId)) {
    return Promise.resolve(false);
  }
  return httpRequest(authUrl, integrationApiKey, `${ORG_ENDPOINT_PATH}/${orgId}/disallow_saml`, "POST").then(
    (httpResponse) => {
      if (httpResponse.statusCode === 401) {
        throw new Error("integrationApiKey is incorrect");
      } else if (httpResponse.statusCode === 429) {
        throw new RateLimitedException(httpResponse.response);
      } else if (httpResponse.statusCode === 404) {
        return false;
      } else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
        throw new Error("Unknown error when disallowing org to setup SAML connection");
      }
      return true;
    }
  );
}
function createOrgSamlConnectionLink(authUrl, integrationApiKey, orgId, expiresInSeconds) {
  return __async(this, null, function* () {
    if (!isValidId(orgId)) {
      return Promise.reject(new Error("Invalid orgId"));
    }
    const request = {
      expires_in_seconds: expiresInSeconds
    };
    const response = yield httpRequest(
      authUrl,
      integrationApiKey,
      `${ORG_ENDPOINT_PATH}/${orgId}/create_saml_connection_link`,
      "POST",
      JSON.stringify(request)
    );
    if (response.statusCode === 401) {
      throw new Error("integrationApiKey is incorrect");
    } else if (response.statusCode === 429) {
      throw new RateLimitedException(response.response);
    } else if (response.statusCode === 404) {
      throw new Error("Org not found");
    } else if (response.statusCode && response.statusCode >= 400) {
      throw new Error(`Error when creating SAML connection link: ${response.response}`);
    }
    return JSON.parse(response.response);
  });
}
function setSamlIdpMetadata(authUrl, integrationApiKey, orgId, setSamlIdpMetadataRequest) {
  if (!isValidId(orgId)) {
    return Promise.resolve(false);
  }
  let request = {
    org_id: orgId,
    idp_entity_id: setSamlIdpMetadataRequest.idpEntityId,
    idp_sso_url: setSamlIdpMetadataRequest.idpSsoUrl,
    idp_certificate: setSamlIdpMetadataRequest.idpCertificate,
    provider: setSamlIdpMetadataRequest.provider
  };
  return httpRequest(
    authUrl,
    integrationApiKey,
    `${BASE_ENDPOINT_PATH}/saml_idp_metadata`,
    "POST",
    JSON.stringify(request)
  ).then(
    (httpResponse) => {
      if (httpResponse.statusCode === 401) {
        throw new Error("integrationApiKey is incorrect");
      } else if (httpResponse.statusCode === 429) {
        throw new RateLimitedException(httpResponse.response);
      } else if (httpResponse.statusCode === 400) {
        throw new UpdateOrgException(httpResponse.response);
      } else if (httpResponse.statusCode === 404) {
        return false;
      } else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
        throw new Error("Unknown error when setting the SAML IdP metadata for an org's SAML connection");
      }
      return true;
    }
  );
}
function samlGoLive(authUrl, integrationApiKey, orgId) {
  if (!isValidId(orgId)) {
    return Promise.resolve(false);
  }
  return httpRequest(authUrl, integrationApiKey, `${BASE_ENDPOINT_PATH}/saml_idp_metadata/go_live/${orgId}`, "POST").then(
    (httpResponse) => {
      if (httpResponse.statusCode === 401) {
        throw new Error("integrationApiKey is incorrect");
      } else if (httpResponse.statusCode === 429) {
        throw new RateLimitedException(httpResponse.response);
      } else if (httpResponse.statusCode === 404) {
        return false;
      } else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
        throw new Error("Unknown error when setting orgs SAML connection to go live");
      }
      return true;
    }
  );
}
function updateOrg(authUrl, integrationApiKey, updateOrgRequest) {
  if (!isValidId(updateOrgRequest.orgId)) {
    return Promise.resolve(false);
  }
  const request = {
    name: updateOrgRequest.name,
    can_setup_saml: updateOrgRequest.canSetupSaml,
    metadata: updateOrgRequest.metadata,
    max_users: updateOrgRequest.maxUsers,
    autojoin_by_domain: updateOrgRequest.canJoinOnEmailDomainMatch,
    restrict_to_domain: updateOrgRequest.membersMustHaveEmailDomainMatch,
    domain: updateOrgRequest.domain,
    legacy_org_id: updateOrgRequest.legacyOrgId,
    require_2fa_by: updateOrgRequest.require2faBy,
    extra_domains: updateOrgRequest.extraDomains
  };
  return httpRequest(
    authUrl,
    integrationApiKey,
    `${ORG_ENDPOINT_PATH}/${updateOrgRequest.orgId}`,
    "PUT",
    JSON.stringify(request)
  ).then((httpResponse) => {
    if (httpResponse.statusCode === 401) {
      throw new Error("integrationApiKey is incorrect");
    } else if (httpResponse.statusCode === 429) {
      throw new RateLimitedException(httpResponse.response);
    } else if (httpResponse.statusCode === 400) {
      throw new UpdateOrgException(httpResponse.response);
    } else if (httpResponse.statusCode === 404) {
      return false;
    } else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
      throw new Error("Unknown error when updating org");
    }
    return true;
  });
}
function subscribeOrgToRoleMapping(authUrl, integrationApiKey, orgId, customRoleMappingName) {
  if (!isValidId(orgId)) {
    return Promise.resolve(false);
  }
  const request = {
    custom_role_mapping_name: customRoleMappingName
  };
  return httpRequest(authUrl, integrationApiKey, `${ORG_ENDPOINT_PATH}/${orgId}`, "PUT", JSON.stringify(request)).then(
    (httpResponse) => {
      if (httpResponse.statusCode === 401) {
        throw new Error("integrationApiKey is incorrect");
      } else if (httpResponse.statusCode === 429) {
        throw new RateLimitedException(httpResponse.response);
      } else if (httpResponse.statusCode === 400) {
        throw new UpdateOrgException(httpResponse.response);
      } else if (httpResponse.statusCode === 404) {
        return false;
      } else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
        throw new Error("Unknown error when subscribing an org to a role mapping");
      }
      return true;
    }
  );
}
function deleteOrg(authUrl, integrationApiKey, orgId) {
  if (!isValidId(orgId)) {
    return Promise.resolve(false);
  }
  return httpRequest(authUrl, integrationApiKey, `${ORG_ENDPOINT_PATH}/${orgId}`, "DELETE").then((httpResponse) => {
    if (httpResponse.statusCode === 401) {
      throw new Error("integrationApiKey is incorrect");
    } else if (httpResponse.statusCode === 429) {
      throw new RateLimitedException(httpResponse.response);
    } else if (httpResponse.statusCode === 404) {
      return false;
    } else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
      throw new Error("Unknown error when deleting org");
    }
    return true;
  });
}
function revokePendingOrgInvite(authUrl, integrationApiKey, revokePendingOrgInviteRequest) {
  const request = {
    invitee_email: revokePendingOrgInviteRequest.inviteeEmail,
    org_id: revokePendingOrgInviteRequest.orgId
  };
  return httpRequest(
    authUrl,
    integrationApiKey,
    `/api/backend/v1/pending_org_invites`,
    "DELETE",
    JSON.stringify(request)
  ).then((httpResponse) => {
    if (httpResponse.statusCode === 401) {
      throw new Error("integrationApiKey is incorrect");
    } else if (httpResponse.statusCode === 429) {
      throw new RateLimitedException(httpResponse.response);
    } else if (httpResponse.statusCode === 400) {
      throw new RevokePendingOrgInviteException(httpResponse.response);
    } else if (httpResponse.statusCode === 404) {
      return false;
    } else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
      throw new Error("Unknown error when revoking org invite");
    }
    return true;
  });
}
function deleteSamlConnection(authUrl, integrationApiKey, orgId) {
  if (!isValidId(orgId)) {
    return Promise.resolve(false);
  }
  return httpRequest(
    authUrl,
    integrationApiKey,
    `${BASE_ENDPOINT_PATH}/saml_idp_metadata/${orgId}`,
    "DELETE"
  ).then((httpResponse) => {
    if (httpResponse.statusCode === 401) {
      throw new Error("integrationApiKey is incorrect");
    } else if (httpResponse.statusCode === 429) {
      throw new RateLimitedException(httpResponse.response);
    } else if (httpResponse.statusCode === 400) {
      throw new RevokePendingOrgInviteException(httpResponse.response);
    } else if (httpResponse.statusCode === 404) {
      return false;
    } else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
      throw new Error("Unknown error when deleting SAML connection");
    }
    return true;
  });
}

// src/api/tokenVerificationMetadata.ts
var ENDPOINT_PATH5 = "/api/v1/token_verification_metadata";
function fetchTokenVerificationMetadata(authUrl, integrationApiKey, manualTokenVerificationMetadata) {
  if (manualTokenVerificationMetadata) {
    return Promise.resolve(manualTokenVerificationMetadata);
  }
  return httpRequest(authUrl, integrationApiKey, ENDPOINT_PATH5, "GET").then((httpResponse) => {
    if (httpResponse.statusCode === 401) {
      console.error("Your API key is incorrect");
      throw new Error("integrationApiKey is incorrect");
    } else if (httpResponse.statusCode === 429) {
      throw new RateLimitedException(httpResponse.response);
    } else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
      console.error(`Error fetching token verification metadata: ${httpResponse.statusCode}`);
      throw new Error("Unknown error when fetching token verification metadata");
    }
    const jsonParse = JSON.parse(httpResponse.response);
    return {
      verifierKey: jsonParse.verifier_key_pem,
      issuer: formatIssuer(authUrl)
    };
  });
}
function formatIssuer(authUrl) {
  return authUrl.origin;
}

// src/api/user.ts
var ENDPOINT_PATH6 = "/api/backend/v1/user";
function fetchUserMetadataByQuery(authUrl, integrationApiKey, pathParam, query) {
  const queryString = formatQueryParameters(query);
  return httpRequest(authUrl, integrationApiKey, `${ENDPOINT_PATH6}/${pathParam}?${queryString}`, "GET").then(
    (httpResponse) => {
      if (httpResponse.statusCode === 401) {
        throw new Error("integrationApiKey is incorrect");
      } else if (httpResponse.statusCode === 429) {
        throw new RateLimitedException(httpResponse.response);
      } else if (httpResponse.statusCode === 404) {
        return null;
      } else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
        throw new Error("Unknown error when fetching user metadata");
      }
      return parseSnakeCaseToCamelCase(httpResponse.response);
    }
  );
}
function fetchUserMetadataByUserIdWithIdCheck(authUrl, integrationApiKey, userId, includeOrgs) {
  if (isValidId(userId)) {
    return fetchUserMetadataByQuery(authUrl, integrationApiKey, userId, { include_orgs: includeOrgs || false });
  } else {
    return Promise.resolve(null);
  }
}
function fetchUsersByQuery(authUrl, integrationApiKey, query) {
  const queryParams = {
    page_size: query.pageSize,
    page_number: query.pageNumber,
    order_by: query.orderBy,
    email_or_username: query.emailOrUsername,
    include_orgs: query.includeOrgs,
    legacy_user_id: query.legacyUserId
  };
  const q = formatQueryParameters(queryParams);
  return httpRequest(authUrl, integrationApiKey, `${ENDPOINT_PATH6}/query?${q}`, "GET").then((httpResponse) => {
    if (httpResponse.statusCode === 401) {
      throw new Error("integrationApiKey is incorrect");
    } else if (httpResponse.statusCode === 429) {
      throw new RateLimitedException(httpResponse.response);
    } else if (httpResponse.statusCode === 400) {
      throw new Error("Invalid query " + httpResponse.response);
    } else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
      throw new Error("Unknown error when fetching users by query");
    }
    return parseSnakeCaseToCamelCase(httpResponse.response);
  });
}
function fetchUsersInOrg(authUrl, integrationApiKey, query) {
  if (!isValidId(query.orgId)) {
    const emptyResponse = {
      users: [],
      totalUsers: 0,
      currentPage: query.pageNumber || 0,
      pageSize: query.pageSize || 10,
      hasMoreResults: false
    };
    return Promise.resolve(emptyResponse);
  }
  const queryParams = {
    page_size: query.pageSize,
    page_number: query.pageNumber,
    include_orgs: query.includeOrgs,
    role: query.role
  };
  const queryString = formatQueryParameters(queryParams);
  return httpRequest(authUrl, integrationApiKey, `${ENDPOINT_PATH6}/org/${query.orgId}?${queryString}`, "GET").then(
    (httpResponse) => {
      if (httpResponse.statusCode === 401) {
        throw new Error("integrationApiKey is incorrect");
      } else if (httpResponse.statusCode === 429) {
        throw new RateLimitedException(httpResponse.response);
      } else if (httpResponse.statusCode === 400) {
        throw new Error("Invalid query " + httpResponse.response);
      } else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
        throw new Error("Unknown error when fetching users in org");
      }
      return parseSnakeCaseToCamelCase(httpResponse.response);
    }
  );
}
function fetchBatchUserMetadata(authUrl, integrationApiKey, type, values, keyFunction, includeOrgs) {
  const queryString = includeOrgs ? formatQueryParameters({ include_orgs: includeOrgs }) : "";
  const jsonBody = { [type]: values };
  return httpRequest(
    authUrl,
    integrationApiKey,
    `${ENDPOINT_PATH6}/${type}?${queryString}`,
    "POST",
    JSON.stringify(jsonBody)
  ).then((httpResponse) => {
    if (httpResponse.statusCode === 401) {
      throw new Error("integrationApiKey is incorrect");
    } else if (httpResponse.statusCode === 429) {
      throw new RateLimitedException(httpResponse.response);
    } else if (httpResponse.statusCode === 400) {
      throw new Error("Bad request " + httpResponse.response);
    } else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
      throw new Error("Unknown error when fetching batch user metadata");
    }
    const userMetadatas = parseSnakeCaseToCamelCase(httpResponse.response);
    const returnValue = {};
    for (let userMetadata of userMetadatas) {
      returnValue[keyFunction(userMetadata)] = userMetadata;
    }
    return returnValue;
  });
}
function createUser(authUrl, integrationApiKey, createUserRequest) {
  const request = {
    email: createUserRequest.email,
    email_confirmed: createUserRequest.emailConfirmed,
    send_email_to_confirm_email_address: createUserRequest.sendEmailToConfirmEmailAddress,
    password: createUserRequest.password,
    ask_user_to_update_password_on_login: createUserRequest.askUserToUpdatePasswordOnLogin,
    ignore_domain_restrictions: createUserRequest.ignoreDomainRestrictions,
    username: createUserRequest.username,
    first_name: createUserRequest.firstName,
    last_name: createUserRequest.lastName,
    properties: createUserRequest.properties
  };
  return httpRequest(authUrl, integrationApiKey, `${ENDPOINT_PATH6}/`, "POST", JSON.stringify(request)).then(
    (httpResponse) => {
      if (httpResponse.statusCode === 401) {
        throw new Error("integrationApiKey is incorrect");
      } else if (httpResponse.statusCode === 429) {
        throw new RateLimitedException(httpResponse.response);
      } else if (httpResponse.statusCode === 400) {
        throw new CreateUserException(httpResponse.response);
      } else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
        throw new Error("Unknown error when creating user");
      }
      return parseSnakeCaseToCamelCase(httpResponse.response);
    }
  );
}
function disableUser(authUrl, integrationApiKey, userId) {
  if (!isValidId(userId)) {
    return Promise.resolve(false);
  }
  return httpRequest(authUrl, integrationApiKey, `${ENDPOINT_PATH6}/${userId}/disable`, "POST").then(
    (httpResponse) => {
      if (httpResponse.statusCode === 401) {
        throw new Error("integrationApiKey is incorrect");
      } else if (httpResponse.statusCode === 429) {
        throw new RateLimitedException(httpResponse.response);
      } else if (httpResponse.statusCode === 404) {
        return false;
      } else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
        throw new Error("Unknown error when disabling user");
      }
      return true;
    }
  );
}
function enableUser(authUrl, integrationApiKey, userId) {
  if (!isValidId(userId)) {
    return Promise.resolve(false);
  }
  return httpRequest(authUrl, integrationApiKey, `${ENDPOINT_PATH6}/${userId}/enable`, "POST").then((httpResponse) => {
    if (httpResponse.statusCode === 401) {
      throw new Error("integrationApiKey is incorrect");
    } else if (httpResponse.statusCode === 429) {
      throw new RateLimitedException(httpResponse.response);
    } else if (httpResponse.statusCode === 404) {
      return false;
    } else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
      throw new Error("Unknown error when enabling user");
    }
    return true;
  });
}
function disableUser2fa(authUrl, integrationApiKey, userId) {
  if (!isValidId(userId)) {
    return Promise.resolve(false);
  }
  return httpRequest(authUrl, integrationApiKey, `${ENDPOINT_PATH6}/${userId}/disable_2fa`, "POST").then(
    (httpResponse) => {
      if (httpResponse.statusCode === 401) {
        throw new Error("integrationApiKey is incorrect");
      } else if (httpResponse.statusCode === 429) {
        throw new RateLimitedException(httpResponse.response);
      } else if (httpResponse.statusCode === 404) {
        return false;
      } else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
        throw new Error("Unknown error when disabling 2FA");
      }
      return true;
    }
  );
}
function resendEmailConfirmation(authUrl, integrationApiKey, userId) {
  if (!isValidId(userId)) {
    return Promise.resolve(false);
  }
  const request = {
    user_id: userId
  };
  return httpRequest(
    authUrl,
    integrationApiKey,
    "/api/backend/v1/resend_email_confirmation",
    "POST",
    JSON.stringify(request)
  ).then((httpResponse) => {
    if (httpResponse.statusCode === 401) {
      throw new Error("integrationApiKey is incorrect");
    } else if (httpResponse.statusCode === 404) {
      return false;
    } else if (httpResponse.statusCode === 429) {
      let errorMessage;
      try {
        errorMessage = JSON.parse(httpResponse.response).user_facing_error;
      } catch (SyntaxError) {
        errorMessage = httpResponse.response;
      }
      throw new RateLimitedException(errorMessage);
    } else if (httpResponse.statusCode === 400) {
      throw new BadRequestException(httpResponse.response);
    } else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
      throw new Error("Unknown error when resending email confirmation");
    }
    return true;
  });
}
function inviteUserToOrg(authUrl, integrationApiKey, inviteUserToOrgRequest) {
  var _a;
  const body = {
    org_id: inviteUserToOrgRequest.orgId,
    email: inviteUserToOrgRequest.email,
    role: inviteUserToOrgRequest.role,
    additional_roles: (_a = inviteUserToOrgRequest.additionalRoles) != null ? _a : []
  };
  return httpRequest(authUrl, integrationApiKey, `/api/backend/v1/invite_user`, "POST", JSON.stringify(body)).then(
    (httpResponse) => {
      if (httpResponse.statusCode === 401) {
        throw new Error("integrationApiKey is incorrect");
      } else if (httpResponse.statusCode === 429) {
        throw new RateLimitedException(httpResponse.response);
      } else if (httpResponse.statusCode === 400) {
        throw new BadRequestException(httpResponse.response);
      } else if (httpResponse.statusCode === 404) {
        return false;
      } else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
        throw new Error("Unknown error when inviting a user to the org");
      }
      return true;
    }
  );
}
function logoutAllUserSessions(authUrl, integrationApiKey, userId) {
  if (!isValidId(userId)) {
    return Promise.resolve(false);
  }
  return httpRequest(authUrl, integrationApiKey, `${ENDPOINT_PATH6}/${userId}/logout_all_sessions`, "POST").then(
    (httpResponse) => {
      if (httpResponse.statusCode === 401) {
        throw new Error("integrationApiKey is incorrect");
      } else if (httpResponse.statusCode === 429) {
        throw new RateLimitedException(httpResponse.response);
      } else if (httpResponse.statusCode === 404) {
        return false;
      } else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
        throw new Error("Unknown error when logging out all sessions");
      }
      return true;
    }
  );
}
function updateUserMetadata(authUrl, integrationApiKey, userId, updateUserMetadataRequest) {
  if (!isValidId(userId)) {
    return Promise.resolve(false);
  }
  const request = {
    username: updateUserMetadataRequest.username,
    first_name: updateUserMetadataRequest.firstName,
    last_name: updateUserMetadataRequest.lastName,
    picture_url: updateUserMetadataRequest.pictureUrl,
    metadata: updateUserMetadataRequest.metadata,
    properties: updateUserMetadataRequest.properties,
    update_password_required: updateUserMetadataRequest.updatePasswordRequired,
    legacy_user_id: updateUserMetadataRequest.legacyUserId
  };
  return httpRequest(authUrl, integrationApiKey, `${ENDPOINT_PATH6}/${userId}`, "PUT", JSON.stringify(request)).then(
    (httpResponse) => {
      if (httpResponse.statusCode === 401) {
        throw new Error("integrationApiKey is incorrect");
      } else if (httpResponse.statusCode === 429) {
        throw new RateLimitedException(httpResponse.response);
      } else if (httpResponse.statusCode === 400) {
        throw new UpdateUserMetadataException(httpResponse.response);
      } else if (httpResponse.statusCode === 404) {
        return false;
      } else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
        throw new Error("Unknown error when updating user metadata");
      }
      return true;
    }
  );
}
function updateUserEmail(authUrl, integrationApiKey, userId, updateUserEmail2) {
  if (!isValidId(userId)) {
    return Promise.resolve(false);
  }
  const request = {
    new_email: updateUserEmail2.newEmail,
    require_email_confirmation: updateUserEmail2.requireEmailConfirmation
  };
  return httpRequest(
    authUrl,
    integrationApiKey,
    `${ENDPOINT_PATH6}/${userId}/email`,
    "PUT",
    JSON.stringify(request)
  ).then((httpResponse) => {
    if (httpResponse.statusCode === 401) {
      throw new Error("integrationApiKey is incorrect");
    } else if (httpResponse.statusCode === 429) {
      throw new RateLimitedException(httpResponse.response);
    } else if (httpResponse.statusCode === 400) {
      throw new UpdateUserEmailException(httpResponse.response);
    } else if (httpResponse.statusCode === 404) {
      return false;
    } else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
      throw new Error("Unknown error when creating user");
    }
    return true;
  });
}
function updateUserPassword(authUrl, integrationApiKey, userId, updateUserPasswordRequest) {
  if (!isValidId(userId)) {
    return Promise.resolve(false);
  }
  const request = {
    password: updateUserPasswordRequest.password,
    ask_user_to_update_password_on_login: updateUserPasswordRequest.askUserToUpdatePasswordOnLogin
  };
  return httpRequest(
    authUrl,
    integrationApiKey,
    `${ENDPOINT_PATH6}/${userId}/password`,
    "PUT",
    JSON.stringify(request)
  ).then((httpResponse) => {
    if (httpResponse.statusCode === 401) {
      throw new Error("integrationApiKey is incorrect");
    } else if (httpResponse.statusCode === 429) {
      throw new RateLimitedException(httpResponse.response);
    } else if (httpResponse.statusCode === 400) {
      throw new UpdateUserPasswordException(httpResponse.response);
    } else if (httpResponse.statusCode === 404) {
      return false;
    } else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
      throw new Error("Unknown error when updating password");
    }
    return true;
  });
}
function enableUserCanCreateOrgs(authUrl, integrationApiKey, userId) {
  if (!isValidId(userId)) {
    return Promise.resolve(false);
  }
  return httpRequest(authUrl, integrationApiKey, `${ENDPOINT_PATH6}/${userId}/can_create_orgs/enable`, "PUT").then(
    (httpResponse) => {
      if (httpResponse.statusCode === 401) {
        throw new Error("integrationApiKey is incorrect");
      } else if (httpResponse.statusCode === 429) {
        throw new RateLimitedException(httpResponse.response);
      } else if (httpResponse.statusCode === 404) {
        return false;
      } else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
        throw new Error("Unknown error when enabling canCreateOrgs");
      }
      return true;
    }
  );
}
function disableUserCanCreateOrgs(authUrl, integrationApiKey, userId) {
  if (!isValidId(userId)) {
    return Promise.resolve(false);
  }
  return httpRequest(authUrl, integrationApiKey, `${ENDPOINT_PATH6}/${userId}/can_create_orgs/disable`, "PUT").then(
    (httpResponse) => {
      if (httpResponse.statusCode === 401) {
        throw new Error("integrationApiKey is incorrect");
      } else if (httpResponse.statusCode === 429) {
        throw new RateLimitedException(httpResponse.response);
      } else if (httpResponse.statusCode === 404) {
        return false;
      } else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
        throw new Error("Unknown error when disabling canCreateOrgs");
      }
      return true;
    }
  );
}
function clearUserPassword(authUrl, integrationApiKey, userId) {
  return __async(this, null, function* () {
    if (!isValidId(userId)) {
      return Promise.resolve(false);
    }
    const httpResponse = yield httpRequest(
      authUrl,
      integrationApiKey,
      `${ENDPOINT_PATH6}/${userId}/clear_password`,
      "PUT"
    );
    if (httpResponse.statusCode === 401) {
      throw new Error("integrationApiKey is incorrect");
    } else if (httpResponse.statusCode === 429) {
      throw new RateLimitedException(httpResponse.response);
    } else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
      throw new Error("Unknown error when clearing password");
    }
    return true;
  });
}
function deleteUser(authUrl, integrationApiKey, userId) {
  if (!isValidId(userId)) {
    return Promise.resolve(false);
  }
  return httpRequest(authUrl, integrationApiKey, `${ENDPOINT_PATH6}/${userId}`, "DELETE").then((httpResponse) => {
    if (httpResponse.statusCode === 401) {
      throw new Error("integrationApiKey is incorrect");
    } else if (httpResponse.statusCode === 429) {
      throw new RateLimitedException(httpResponse.response);
    } else if (httpResponse.statusCode === 404) {
      return false;
    } else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
      throw new Error("Unknown error when deleting user");
    }
    return true;
  });
}
function fetchUserSignupQueryParams(authUrl, integrationApiKey, userId) {
  return __async(this, null, function* () {
    if (!isValidId(userId)) {
      return Promise.resolve(null);
    }
    const httpResponse = yield httpRequest(
      authUrl,
      integrationApiKey,
      `${ENDPOINT_PATH6}/${userId}/signup_query_parameters`,
      "GET"
    );
    if (httpResponse.statusCode === 401) {
      throw new Error("integrationApiKey is incorrect");
    } else if (httpResponse.statusCode === 429) {
      throw new RateLimitedException(httpResponse.response);
    } else if (httpResponse.statusCode === 404) {
      return null;
    } else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
      throw new Error("Unknown error when fetching user signup query params");
    }
    const snakeCase = JSON.parse(httpResponse.response);
    return { userSignupQueryParameters: snakeCase["user_signup_query_parameters"] };
  });
}

// src/validators.ts
function validatePersonalApiKey(authUrl, integrationApiKey, apiKeyToken) {
  return __async(this, null, function* () {
    const apiKeyValidation = yield validateApiKey(authUrl, integrationApiKey, apiKeyToken);
    if (!apiKeyValidation.user || apiKeyValidation.org) {
      throw new ApiKeyValidateException(JSON.stringify({ api_key_token: ["Not a personal API Key"] }));
    }
    return {
      user: apiKeyValidation.user,
      metadata: apiKeyValidation.metadata
    };
  });
}
function validateOrgApiKey(authUrl, integrationApiKey, apiKeyToken) {
  return __async(this, null, function* () {
    const apiKeyValidation = yield validateApiKey(authUrl, integrationApiKey, apiKeyToken);
    if (!apiKeyValidation.org) {
      throw new ApiKeyValidateException(JSON.stringify({ api_key_token: ["Not an org API Key"] }));
    }
    return {
      org: apiKeyValidation.org,
      metadata: apiKeyValidation.metadata,
      user: apiKeyValidation.user,
      userInOrg: apiKeyValidation.userInOrg
    };
  });
}

// src/api.ts
function getApis(authUrl, integrationApiKey) {
  function fetchTokenVerificationMetadataWrapper() {
    return fetchTokenVerificationMetadata(authUrl, integrationApiKey);
  }
  function fetchUserMetadataByUserId(userId, includeOrgs) {
    return fetchUserMetadataByUserIdWithIdCheck(authUrl, integrationApiKey, userId, includeOrgs);
  }
  function fetchUserMetadataByEmail(email, includeOrgs) {
    return fetchUserMetadataByQuery(authUrl, integrationApiKey, "email", {
      email,
      include_orgs: includeOrgs || false
    });
  }
  function fetchUserMetadataByUsername(username, includeOrgs) {
    return fetchUserMetadataByQuery(authUrl, integrationApiKey, "username", {
      username,
      include_orgs: includeOrgs || false
    });
  }
  function fetchBatchUserMetadataByUserIds(userIds, includeOrgs) {
    return fetchBatchUserMetadata(
      authUrl,
      integrationApiKey,
      "user_ids",
      userIds,
      (x) => x.userId,
      includeOrgs || false
    );
  }
  function fetchBatchUserMetadataByEmails(emails, includeOrgs) {
    return fetchBatchUserMetadata(
      authUrl,
      integrationApiKey,
      "emails",
      emails,
      (x) => x.email,
      includeOrgs || false
    );
  }
  function fetchBatchUserMetadataByUsernames(usernames, includeOrgs) {
    return fetchBatchUserMetadata(
      authUrl,
      integrationApiKey,
      "usernames",
      usernames,
      (x) => x.username || "",
      includeOrgs || false
    );
  }
  function fetchOrgWrapper(orgId) {
    return fetchOrg(authUrl, integrationApiKey, orgId);
  }
  function fetchOrgsByQueryWrapper(orgQuery) {
    return fetchOrgByQuery(authUrl, integrationApiKey, orgQuery);
  }
  function fetchCustomRoleMappingsWrapper() {
    return fetchCustomRoleMappings(authUrl, integrationApiKey);
  }
  function fetchUsersByQueryWrapper(usersQuery) {
    return fetchUsersByQuery(authUrl, integrationApiKey, usersQuery);
  }
  function fetchUsersInOrgWrapper(usersInOrgQuery) {
    return fetchUsersInOrg(authUrl, integrationApiKey, usersInOrgQuery);
  }
  function fetchUserSignupQueryParamsWrapper(userId) {
    return fetchUserSignupQueryParams(authUrl, integrationApiKey, userId);
  }
  function createUserWrapper(createUserRequest) {
    return createUser(authUrl, integrationApiKey, createUserRequest);
  }
  function clearUserPasswordWrapper(userId) {
    return clearUserPassword(authUrl, integrationApiKey, userId);
  }
  function updateUserMetadataWrapper(userId, updateUserMetadataRequest) {
    return updateUserMetadata(authUrl, integrationApiKey, userId, updateUserMetadataRequest);
  }
  function deleteUserWrapper(userId) {
    return deleteUser(authUrl, integrationApiKey, userId);
  }
  function disableUserWrapper(userId) {
    return disableUser(authUrl, integrationApiKey, userId);
  }
  function enableUserWrapper(userId) {
    return enableUser(authUrl, integrationApiKey, userId);
  }
  function disableUser2faWrapper(userId) {
    return disableUser2fa(authUrl, integrationApiKey, userId);
  }
  function resendEmailConfirmationWrapper(userId) {
    return resendEmailConfirmation(authUrl, integrationApiKey, userId);
  }
  function updateUserEmailWrapper(userId, updateUserEmailRequest) {
    return updateUserEmail(authUrl, integrationApiKey, userId, updateUserEmailRequest);
  }
  function updateUserPasswordWrapper(userId, updateUserPasswordRequest) {
    return updateUserPassword(authUrl, integrationApiKey, userId, updateUserPasswordRequest);
  }
  function enableUserCanCreateOrgsWrapper(userId) {
    return enableUserCanCreateOrgs(authUrl, integrationApiKey, userId);
  }
  function disableUserCanCreateOrgsWrapper(userId) {
    return disableUserCanCreateOrgs(authUrl, integrationApiKey, userId);
  }
  function createMagicLinkWrapper(createMagicLinkRequest) {
    return createMagicLink(authUrl, integrationApiKey, createMagicLinkRequest);
  }
  function createAccessTokenWrapper(createAccessTokenRequest) {
    return createAccessToken(authUrl, integrationApiKey, createAccessTokenRequest);
  }
  function migrateUserFromExternalSourceWrapper(migrateUserFromExternalSourceRequest) {
    return migrateUserFromExternalSource(authUrl, integrationApiKey, migrateUserFromExternalSourceRequest);
  }
  function migrateUserPasswordWrapper(migrateUserPasswordRequest) {
    return migrateUserPassword(authUrl, integrationApiKey, migrateUserPasswordRequest);
  }
  function createOrgWrapper(createOrgRequest) {
    return createOrg(authUrl, integrationApiKey, createOrgRequest);
  }
  function addUserToOrgWrapper(addUserToOrgRequest) {
    return addUserToOrg(authUrl, integrationApiKey, addUserToOrgRequest);
  }
  function changeUserRoleInOrgWrapper(changeUserRoleInOrgRequest) {
    return changeUserRoleInOrg(authUrl, integrationApiKey, changeUserRoleInOrgRequest);
  }
  function removeUserFromOrgWrapper(removeUserFromOrgRequest) {
    return removeUserFromOrg(authUrl, integrationApiKey, removeUserFromOrgRequest);
  }
  function updateOrgWrapper(updateOrgRequest) {
    return updateOrg(authUrl, integrationApiKey, updateOrgRequest);
  }
  function subscribeOrgToRoleMappingWrapper(orgId, customRoleMappingName) {
    return subscribeOrgToRoleMapping(authUrl, integrationApiKey, orgId, customRoleMappingName);
  }
  function deleteOrgWrapper(orgId) {
    return deleteOrg(authUrl, integrationApiKey, orgId);
  }
  function allowOrgToSetupSamlConnectionWrapper(orgId) {
    return allowOrgToSetupSamlConnection(authUrl, integrationApiKey, orgId);
  }
  function disallowOrgToSetupSamlConnectionWrapper(orgId) {
    return disallowOrgToSetupSamlConnection(authUrl, integrationApiKey, orgId);
  }
  function createOrgSamlConnectionLinkWrapper(orgId, expiresInSeconds) {
    return createOrgSamlConnectionLink(authUrl, integrationApiKey, orgId, expiresInSeconds);
  }
  function fetchSamlSpMetadataWrapper(orgId) {
    return fetchSamlSpMetadata(authUrl, integrationApiKey, orgId);
  }
  function setSamlIdpMetadataWrapper(orgId, samlIdpMetadata) {
    return setSamlIdpMetadata(authUrl, integrationApiKey, orgId, samlIdpMetadata);
  }
  function samlGoLiveWrapper(orgId) {
    return samlGoLive(authUrl, integrationApiKey, orgId);
  }
  function deleteSamlConnectionWrapper(orgId) {
    return deleteSamlConnection(authUrl, integrationApiKey, orgId);
  }
  function inviteUserToOrgWrapper(inviteUserToOrgRequest) {
    return inviteUserToOrg(authUrl, integrationApiKey, inviteUserToOrgRequest);
  }
  function logoutAllUserSessionsWrapper(userId) {
    return logoutAllUserSessions(authUrl, integrationApiKey, userId);
  }
  function fetchPendingInvitesWrapper(params) {
    return fetchPendingInvites(authUrl, integrationApiKey, params);
  }
  function revokePendingOrgInviteWrapper(revokePendingOrgInviteRequest) {
    return revokePendingOrgInvite(authUrl, integrationApiKey, revokePendingOrgInviteRequest);
  }
  function fetchApiKeyWrapper(apiKeyId) {
    return fetchApiKey(authUrl, integrationApiKey, apiKeyId);
  }
  function fetchCurrentApiKeysWrapper(apiKeyQuery) {
    return fetchCurrentApiKeys(authUrl, integrationApiKey, apiKeyQuery);
  }
  function fetchArchivedApiKeysWrapper(apiKeyQuery) {
    return fetchArchivedApiKeys(authUrl, integrationApiKey, apiKeyQuery);
  }
  function createApiKeyWrapper(apiKeyCreate) {
    return createApiKey(authUrl, integrationApiKey, apiKeyCreate);
  }
  function updateApiKeyWrapper(apiKeyId, ApiKeyUpdate) {
    return updateApiKey(authUrl, integrationApiKey, apiKeyId, ApiKeyUpdate);
  }
  function deleteApiKeyWrapper(apiKeyId) {
    return deleteApiKey(authUrl, integrationApiKey, apiKeyId);
  }
  function validatePersonalApiKeyWrapper(apiKeyToken) {
    return validatePersonalApiKey(authUrl, integrationApiKey, apiKeyToken);
  }
  function validateOrgApiKeyWrapper(apiKeyToken) {
    return validateOrgApiKey(authUrl, integrationApiKey, apiKeyToken);
  }
  function validateApiKeyWrapper(apiKeyToken) {
    return validateApiKey(authUrl, integrationApiKey, apiKeyToken);
  }
  function verifyStepUpTotpChallengeWrapper(verifyTotpChallengeRequest) {
    return verifyStepUpTotpChallenge(authUrl, integrationApiKey, verifyTotpChallengeRequest);
  }
  function verifyStepUpGrantWrapper(verifyStepUpGrantRequest) {
    return verifyStepUpGrant(authUrl, integrationApiKey, verifyStepUpGrantRequest);
  }
  return {
    // fetching functions
    fetchTokenVerificationMetadata: fetchTokenVerificationMetadataWrapper,
    fetchUserMetadataByUserId,
    fetchUserMetadataByEmail,
    fetchUserMetadataByUsername,
    fetchBatchUserMetadataByUserIds,
    fetchBatchUserMetadataByEmails,
    fetchBatchUserMetadataByUsernames,
    fetchOrg: fetchOrgWrapper,
    fetchOrgByQuery: fetchOrgsByQueryWrapper,
    fetchCustomRoleMappings: fetchCustomRoleMappingsWrapper,
    fetchUsersByQuery: fetchUsersByQueryWrapper,
    fetchUsersInOrg: fetchUsersInOrgWrapper,
    fetchUserSignupQueryParams: fetchUserSignupQueryParamsWrapper,
    // user management functions
    createUser: createUserWrapper,
    updateUserMetadata: updateUserMetadataWrapper,
    updateUserEmail: updateUserEmailWrapper,
    updateUserPassword: updateUserPasswordWrapper,
    clearUserPassword: clearUserPasswordWrapper,
    createMagicLink: createMagicLinkWrapper,
    createAccessToken: createAccessTokenWrapper,
    migrateUserFromExternalSource: migrateUserFromExternalSourceWrapper,
    migrateUserPassword: migrateUserPasswordWrapper,
    deleteUser: deleteUserWrapper,
    disableUser: disableUserWrapper,
    enableUser: enableUserWrapper,
    disableUser2fa: disableUser2faWrapper,
    resendEmailConfirmation: resendEmailConfirmationWrapper,
    enableUserCanCreateOrgs: enableUserCanCreateOrgsWrapper,
    disableUserCanCreateOrgs: disableUserCanCreateOrgsWrapper,
    logoutAllUserSessions: logoutAllUserSessionsWrapper,
    // org management functions
    createOrg: createOrgWrapper,
    addUserToOrg: addUserToOrgWrapper,
    changeUserRoleInOrg: changeUserRoleInOrgWrapper,
    removeUserFromOrg: removeUserFromOrgWrapper,
    updateOrg: updateOrgWrapper,
    subscribeOrgToRoleMapping: subscribeOrgToRoleMappingWrapper,
    deleteOrg: deleteOrgWrapper,
    allowOrgToSetupSamlConnection: allowOrgToSetupSamlConnectionWrapper,
    disallowOrgToSetupSamlConnection: disallowOrgToSetupSamlConnectionWrapper,
    createOrgSamlConnectionLink: createOrgSamlConnectionLinkWrapper,
    inviteUserToOrg: inviteUserToOrgWrapper,
    fetchPendingInvites: fetchPendingInvitesWrapper,
    revokePendingOrgInvite: revokePendingOrgInviteWrapper,
    fetchSamlSpMetadata: fetchSamlSpMetadataWrapper,
    setSamlIdpMetadata: setSamlIdpMetadataWrapper,
    samlGoLive: samlGoLiveWrapper,
    deleteSamlConnection: deleteSamlConnectionWrapper,
    // api keys functions
    fetchApiKey: fetchApiKeyWrapper,
    fetchCurrentApiKeys: fetchCurrentApiKeysWrapper,
    fetchArchivedApiKeys: fetchArchivedApiKeysWrapper,
    createApiKey: createApiKeyWrapper,
    updateApiKey: updateApiKeyWrapper,
    deleteApiKey: deleteApiKeyWrapper,
    validateApiKey: validateApiKeyWrapper,
    validatePersonalApiKey: validatePersonalApiKeyWrapper,
    validateOrgApiKey: validateOrgApiKeyWrapper,
    // step-up mfa functions
    verifyStepUpTotpChallenge: verifyStepUpTotpChallengeWrapper,
    verifyStepUpGrant: verifyStepUpGrantWrapper
  };
}

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __rest(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
              t[p[i]] = s[p[i]];
      }
  return t;
}

function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
  return new (P || (P = Promise))(function (resolve, reject) {
      function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
      function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
      function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}

typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

const encoder = new TextEncoder();
const decoder = new TextDecoder();
function concat(...buffers) {
    const size = buffers.reduce((acc, { length }) => acc + length, 0);
    const buf = new Uint8Array(size);
    let i = 0;
    buffers.forEach((buffer) => {
        buf.set(buffer, i);
        i += buffer.length;
    });
    return buf;
}

function normalize(input) {
    let encoded = input;
    if (encoded instanceof Uint8Array) {
        encoded = decoder.decode(encoded);
    }
    return encoded;
}
const decode = (input) => new Uint8Array(Buffer.from(normalize(input), 'base64'));

class JOSEError extends Error {
    static get code() {
        return 'ERR_JOSE_GENERIC';
    }
    code = 'ERR_JOSE_GENERIC';
    constructor(message) {
        super(message);
        this.name = this.constructor.name;
        Error.captureStackTrace?.(this, this.constructor);
    }
}
class JWTClaimValidationFailed extends JOSEError {
    static get code() {
        return 'ERR_JWT_CLAIM_VALIDATION_FAILED';
    }
    code = 'ERR_JWT_CLAIM_VALIDATION_FAILED';
    claim;
    reason;
    constructor(message, claim = 'unspecified', reason = 'unspecified') {
        super(message);
        this.claim = claim;
        this.reason = reason;
    }
}
class JWTExpired extends JOSEError {
    static get code() {
        return 'ERR_JWT_EXPIRED';
    }
    code = 'ERR_JWT_EXPIRED';
    claim;
    reason;
    constructor(message, claim = 'unspecified', reason = 'unspecified') {
        super(message);
        this.claim = claim;
        this.reason = reason;
    }
}
class JOSEAlgNotAllowed extends JOSEError {
    static get code() {
        return 'ERR_JOSE_ALG_NOT_ALLOWED';
    }
    code = 'ERR_JOSE_ALG_NOT_ALLOWED';
}
class JOSENotSupported extends JOSEError {
    static get code() {
        return 'ERR_JOSE_NOT_SUPPORTED';
    }
    code = 'ERR_JOSE_NOT_SUPPORTED';
}
class JWSInvalid extends JOSEError {
    static get code() {
        return 'ERR_JWS_INVALID';
    }
    code = 'ERR_JWS_INVALID';
}
class JWTInvalid extends JOSEError {
    static get code() {
        return 'ERR_JWT_INVALID';
    }
    code = 'ERR_JWT_INVALID';
}
class JWSSignatureVerificationFailed extends JOSEError {
    static get code() {
        return 'ERR_JWS_SIGNATURE_VERIFICATION_FAILED';
    }
    code = 'ERR_JWS_SIGNATURE_VERIFICATION_FAILED';
    message = 'signature verification failed';
}

var isKeyObject = (obj) => util.types.isKeyObject(obj);

const webcrypto = crypto.webcrypto;
const isCryptoKey = (key) => util.types.isCryptoKey(key);

function unusable(name, prop = 'algorithm.name') {
    return new TypeError(`CryptoKey does not support this operation, its ${prop} must be ${name}`);
}
function isAlgorithm(algorithm, name) {
    return algorithm.name === name;
}
function getHashLength(hash) {
    return parseInt(hash.name.slice(4), 10);
}
function getNamedCurve$1(alg) {
    switch (alg) {
        case 'ES256':
            return 'P-256';
        case 'ES384':
            return 'P-384';
        case 'ES512':
            return 'P-521';
        default:
            throw new Error('unreachable');
    }
}
function checkUsage(key, usages) {
    if (usages.length && !usages.some((expected) => key.usages.includes(expected))) {
        let msg = 'CryptoKey does not support this operation, its usages must include ';
        if (usages.length > 2) {
            const last = usages.pop();
            msg += `one of ${usages.join(', ')}, or ${last}.`;
        }
        else if (usages.length === 2) {
            msg += `one of ${usages[0]} or ${usages[1]}.`;
        }
        else {
            msg += `${usages[0]}.`;
        }
        throw new TypeError(msg);
    }
}
function checkSigCryptoKey(key, alg, ...usages) {
    switch (alg) {
        case 'HS256':
        case 'HS384':
        case 'HS512': {
            if (!isAlgorithm(key.algorithm, 'HMAC'))
                throw unusable('HMAC');
            const expected = parseInt(alg.slice(2), 10);
            const actual = getHashLength(key.algorithm.hash);
            if (actual !== expected)
                throw unusable(`SHA-${expected}`, 'algorithm.hash');
            break;
        }
        case 'RS256':
        case 'RS384':
        case 'RS512': {
            if (!isAlgorithm(key.algorithm, 'RSASSA-PKCS1-v1_5'))
                throw unusable('RSASSA-PKCS1-v1_5');
            const expected = parseInt(alg.slice(2), 10);
            const actual = getHashLength(key.algorithm.hash);
            if (actual !== expected)
                throw unusable(`SHA-${expected}`, 'algorithm.hash');
            break;
        }
        case 'PS256':
        case 'PS384':
        case 'PS512': {
            if (!isAlgorithm(key.algorithm, 'RSA-PSS'))
                throw unusable('RSA-PSS');
            const expected = parseInt(alg.slice(2), 10);
            const actual = getHashLength(key.algorithm.hash);
            if (actual !== expected)
                throw unusable(`SHA-${expected}`, 'algorithm.hash');
            break;
        }
        case 'EdDSA': {
            if (key.algorithm.name !== 'Ed25519' && key.algorithm.name !== 'Ed448') {
                throw unusable('Ed25519 or Ed448');
            }
            break;
        }
        case 'ES256':
        case 'ES384':
        case 'ES512': {
            if (!isAlgorithm(key.algorithm, 'ECDSA'))
                throw unusable('ECDSA');
            const expected = getNamedCurve$1(alg);
            const actual = key.algorithm.namedCurve;
            if (actual !== expected)
                throw unusable(expected, 'algorithm.namedCurve');
            break;
        }
        default:
            throw new TypeError('CryptoKey does not support this operation');
    }
    checkUsage(key, usages);
}

function message(msg, actual, ...types) {
    if (types.length > 2) {
        const last = types.pop();
        msg += `one of type ${types.join(', ')}, or ${last}.`;
    }
    else if (types.length === 2) {
        msg += `one of type ${types[0]} or ${types[1]}.`;
    }
    else {
        msg += `of type ${types[0]}.`;
    }
    if (actual == null) {
        msg += ` Received ${actual}`;
    }
    else if (typeof actual === 'function' && actual.name) {
        msg += ` Received function ${actual.name}`;
    }
    else if (typeof actual === 'object' && actual != null) {
        if (actual.constructor && actual.constructor.name) {
            msg += ` Received an instance of ${actual.constructor.name}`;
        }
    }
    return msg;
}
var invalidKeyInput = (actual, ...types) => {
    return message('Key must be ', actual, ...types);
};
function withAlg(alg, actual, ...types) {
    return message(`Key for the ${alg} algorithm must be `, actual, ...types);
}

var isKeyLike = (key) => isKeyObject(key) || isCryptoKey(key);
const types = ['KeyObject'];
if (globalThis.CryptoKey || webcrypto?.CryptoKey) {
    types.push('CryptoKey');
}

const isDisjoint = (...headers) => {
    const sources = headers.filter(Boolean);
    if (sources.length === 0 || sources.length === 1) {
        return true;
    }
    let acc;
    for (const header of sources) {
        const parameters = Object.keys(header);
        if (!acc || acc.size === 0) {
            acc = new Set(parameters);
            continue;
        }
        for (const parameter of parameters) {
            if (acc.has(parameter)) {
                return false;
            }
            acc.add(parameter);
        }
    }
    return true;
};

function isObjectLike(value) {
    return typeof value === 'object' && value !== null;
}
function isObject(input) {
    if (!isObjectLike(input) || Object.prototype.toString.call(input) !== '[object Object]') {
        return false;
    }
    if (Object.getPrototypeOf(input) === null) {
        return true;
    }
    let proto = input;
    while (Object.getPrototypeOf(proto) !== null) {
        proto = Object.getPrototypeOf(proto);
    }
    return Object.getPrototypeOf(input) === proto;
}

const namedCurveToJOSE = (namedCurve) => {
    switch (namedCurve) {
        case 'prime256v1':
            return 'P-256';
        case 'secp384r1':
            return 'P-384';
        case 'secp521r1':
            return 'P-521';
        case 'secp256k1':
            return 'secp256k1';
        default:
            throw new JOSENotSupported('Unsupported key curve for this operation');
    }
};
const getNamedCurve = (kee, raw) => {
    let key;
    if (isCryptoKey(kee)) {
        key = KeyObject.from(kee);
    }
    else if (isKeyObject(kee)) {
        key = kee;
    }
    else {
        throw new TypeError(invalidKeyInput(kee, ...types));
    }
    if (key.type === 'secret') {
        throw new TypeError('only "private" or "public" type keys can be used for this operation');
    }
    switch (key.asymmetricKeyType) {
        case 'ed25519':
        case 'ed448':
            return `Ed${key.asymmetricKeyType.slice(2)}`;
        case 'x25519':
        case 'x448':
            return `X${key.asymmetricKeyType.slice(1)}`;
        case 'ec': {
            let namedCurve = key.asymmetricKeyDetails.namedCurve;
            if (raw) {
                return namedCurve;
            }
            return namedCurveToJOSE(namedCurve);
        }
        default:
            throw new TypeError('Invalid asymmetric key type for this operation');
    }
};

var checkKeyLength = (key, alg) => {
    const { modulusLength } = key.asymmetricKeyDetails;
    if (typeof modulusLength !== 'number' || modulusLength < 2048) {
        throw new TypeError(`${alg} requires key modulusLength to be 2048 bits or larger`);
    }
};

const fromSPKI = (pem) => createPublicKey({
    key: Buffer.from(pem.replace(/(?:-----(?:BEGIN|END) PUBLIC KEY-----|\s)/g, ''), 'base64'),
    type: 'spki',
    format: 'der',
});

async function importSPKI(spki, alg, options) {
    if (typeof spki !== 'string' || spki.indexOf('-----BEGIN PUBLIC KEY-----') !== 0) {
        throw new TypeError('"spki" must be SPKI formatted string');
    }
    return fromSPKI(spki);
}

const symmetricTypeCheck = (alg, key) => {
    if (key instanceof Uint8Array)
        return;
    if (!isKeyLike(key)) {
        throw new TypeError(withAlg(alg, key, ...types, 'Uint8Array'));
    }
    if (key.type !== 'secret') {
        throw new TypeError(`${types.join(' or ')} instances for symmetric algorithms must be of type "secret"`);
    }
};
const asymmetricTypeCheck = (alg, key, usage) => {
    if (!isKeyLike(key)) {
        throw new TypeError(withAlg(alg, key, ...types));
    }
    if (key.type === 'secret') {
        throw new TypeError(`${types.join(' or ')} instances for asymmetric algorithms must not be of type "secret"`);
    }
    if (usage === 'sign' && key.type === 'public') {
        throw new TypeError(`${types.join(' or ')} instances for asymmetric algorithm signing must be of type "private"`);
    }
    if (usage === 'decrypt' && key.type === 'public') {
        throw new TypeError(`${types.join(' or ')} instances for asymmetric algorithm decryption must be of type "private"`);
    }
    if (key.algorithm && usage === 'verify' && key.type === 'private') {
        throw new TypeError(`${types.join(' or ')} instances for asymmetric algorithm verifying must be of type "public"`);
    }
    if (key.algorithm && usage === 'encrypt' && key.type === 'private') {
        throw new TypeError(`${types.join(' or ')} instances for asymmetric algorithm encryption must be of type "public"`);
    }
};
const checkKeyType = (alg, key, usage) => {
    const symmetric = alg.startsWith('HS') ||
        alg === 'dir' ||
        alg.startsWith('PBES2') ||
        /^A\d{3}(?:GCM)?KW$/.test(alg);
    if (symmetric) {
        symmetricTypeCheck(alg, key);
    }
    else {
        asymmetricTypeCheck(alg, key, usage);
    }
};

function validateCrit(Err, recognizedDefault, recognizedOption, protectedHeader, joseHeader) {
    if (joseHeader.crit !== undefined && protectedHeader.crit === undefined) {
        throw new Err('"crit" (Critical) Header Parameter MUST be integrity protected');
    }
    if (!protectedHeader || protectedHeader.crit === undefined) {
        return new Set();
    }
    if (!Array.isArray(protectedHeader.crit) ||
        protectedHeader.crit.length === 0 ||
        protectedHeader.crit.some((input) => typeof input !== 'string' || input.length === 0)) {
        throw new Err('"crit" (Critical) Header Parameter MUST be an array of non-empty strings when present');
    }
    let recognized;
    if (recognizedOption !== undefined) {
        recognized = new Map([...Object.entries(recognizedOption), ...recognizedDefault.entries()]);
    }
    else {
        recognized = recognizedDefault;
    }
    for (const parameter of protectedHeader.crit) {
        if (!recognized.has(parameter)) {
            throw new JOSENotSupported(`Extension Header Parameter "${parameter}" is not recognized`);
        }
        if (joseHeader[parameter] === undefined) {
            throw new Err(`Extension Header Parameter "${parameter}" is missing`);
        }
        else if (recognized.get(parameter) && protectedHeader[parameter] === undefined) {
            throw new Err(`Extension Header Parameter "${parameter}" MUST be integrity protected`);
        }
    }
    return new Set(protectedHeader.crit);
}

const validateAlgorithms = (option, algorithms) => {
    if (algorithms !== undefined &&
        (!Array.isArray(algorithms) || algorithms.some((s) => typeof s !== 'string'))) {
        throw new TypeError(`"${option}" option must be an array of strings`);
    }
    if (!algorithms) {
        return undefined;
    }
    return new Set(algorithms);
};

function dsaDigest(alg) {
    switch (alg) {
        case 'PS256':
        case 'RS256':
        case 'ES256':
        case 'ES256K':
            return 'sha256';
        case 'PS384':
        case 'RS384':
        case 'ES384':
            return 'sha384';
        case 'PS512':
        case 'RS512':
        case 'ES512':
            return 'sha512';
        case 'EdDSA':
            return undefined;
        default:
            throw new JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);
    }
}

const PSS = {
    padding: constants.RSA_PKCS1_PSS_PADDING,
    saltLength: constants.RSA_PSS_SALTLEN_DIGEST,
};
const ecCurveAlgMap = new Map([
    ['ES256', 'P-256'],
    ['ES256K', 'secp256k1'],
    ['ES384', 'P-384'],
    ['ES512', 'P-521'],
]);
function keyForCrypto(alg, key) {
    switch (alg) {
        case 'EdDSA':
            if (!['ed25519', 'ed448'].includes(key.asymmetricKeyType)) {
                throw new TypeError('Invalid key for this operation, its asymmetricKeyType must be ed25519 or ed448');
            }
            return key;
        case 'RS256':
        case 'RS384':
        case 'RS512':
            if (key.asymmetricKeyType !== 'rsa') {
                throw new TypeError('Invalid key for this operation, its asymmetricKeyType must be rsa');
            }
            checkKeyLength(key, alg);
            return key;
        case 'PS256':
        case 'PS384':
        case 'PS512':
            if (key.asymmetricKeyType === 'rsa-pss') {
                const { hashAlgorithm, mgf1HashAlgorithm, saltLength } = key.asymmetricKeyDetails;
                const length = parseInt(alg.slice(-3), 10);
                if (hashAlgorithm !== undefined &&
                    (hashAlgorithm !== `sha${length}` || mgf1HashAlgorithm !== hashAlgorithm)) {
                    throw new TypeError(`Invalid key for this operation, its RSA-PSS parameters do not meet the requirements of "alg" ${alg}`);
                }
                if (saltLength !== undefined && saltLength > length >> 3) {
                    throw new TypeError(`Invalid key for this operation, its RSA-PSS parameter saltLength does not meet the requirements of "alg" ${alg}`);
                }
            }
            else if (key.asymmetricKeyType !== 'rsa') {
                throw new TypeError('Invalid key for this operation, its asymmetricKeyType must be rsa or rsa-pss');
            }
            checkKeyLength(key, alg);
            return { key, ...PSS };
        case 'ES256':
        case 'ES256K':
        case 'ES384':
        case 'ES512': {
            if (key.asymmetricKeyType !== 'ec') {
                throw new TypeError('Invalid key for this operation, its asymmetricKeyType must be ec');
            }
            const actual = getNamedCurve(key);
            const expected = ecCurveAlgMap.get(alg);
            if (actual !== expected) {
                throw new TypeError(`Invalid key curve for the algorithm, its curve must be ${expected}, got ${actual}`);
            }
            return { dsaEncoding: 'ieee-p1363', key };
        }
        default:
            throw new JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);
    }
}

function hmacDigest(alg) {
    switch (alg) {
        case 'HS256':
            return 'sha256';
        case 'HS384':
            return 'sha384';
        case 'HS512':
            return 'sha512';
        default:
            throw new JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);
    }
}

function getSignVerifyKey(alg, key, usage) {
    if (key instanceof Uint8Array) {
        if (!alg.startsWith('HS')) {
            throw new TypeError(invalidKeyInput(key, ...types));
        }
        return createSecretKey(key);
    }
    if (key instanceof KeyObject) {
        return key;
    }
    if (isCryptoKey(key)) {
        checkSigCryptoKey(key, alg, usage);
        return KeyObject.from(key);
    }
    throw new TypeError(invalidKeyInput(key, ...types, 'Uint8Array'));
}

const oneShotSign = promisify(crypto.sign);
const sign = async (alg, key, data) => {
    const keyObject = getSignVerifyKey(alg, key, 'sign');
    if (alg.startsWith('HS')) {
        const hmac = crypto.createHmac(hmacDigest(alg), keyObject);
        hmac.update(data);
        return hmac.digest();
    }
    return oneShotSign(dsaDigest(alg), data, keyForCrypto(alg, keyObject));
};

const oneShotVerify = promisify(crypto.verify);
const verify = async (alg, key, signature, data) => {
    const keyObject = getSignVerifyKey(alg, key, 'verify');
    if (alg.startsWith('HS')) {
        const expected = await sign(alg, keyObject, data);
        const actual = signature;
        try {
            return crypto.timingSafeEqual(actual, expected);
        }
        catch {
            return false;
        }
    }
    const algorithm = dsaDigest(alg);
    const keyInput = keyForCrypto(alg, keyObject);
    try {
        return await oneShotVerify(algorithm, data, keyInput, signature);
    }
    catch {
        return false;
    }
};

async function flattenedVerify(jws, key, options) {
    if (!isObject(jws)) {
        throw new JWSInvalid('Flattened JWS must be an object');
    }
    if (jws.protected === undefined && jws.header === undefined) {
        throw new JWSInvalid('Flattened JWS must have either of the "protected" or "header" members');
    }
    if (jws.protected !== undefined && typeof jws.protected !== 'string') {
        throw new JWSInvalid('JWS Protected Header incorrect type');
    }
    if (jws.payload === undefined) {
        throw new JWSInvalid('JWS Payload missing');
    }
    if (typeof jws.signature !== 'string') {
        throw new JWSInvalid('JWS Signature missing or incorrect type');
    }
    if (jws.header !== undefined && !isObject(jws.header)) {
        throw new JWSInvalid('JWS Unprotected Header incorrect type');
    }
    let parsedProt = {};
    if (jws.protected) {
        try {
            const protectedHeader = decode(jws.protected);
            parsedProt = JSON.parse(decoder.decode(protectedHeader));
        }
        catch {
            throw new JWSInvalid('JWS Protected Header is invalid');
        }
    }
    if (!isDisjoint(parsedProt, jws.header)) {
        throw new JWSInvalid('JWS Protected and JWS Unprotected Header Parameter names must be disjoint');
    }
    const joseHeader = {
        ...parsedProt,
        ...jws.header,
    };
    const extensions = validateCrit(JWSInvalid, new Map([['b64', true]]), options?.crit, parsedProt, joseHeader);
    let b64 = true;
    if (extensions.has('b64')) {
        b64 = parsedProt.b64;
        if (typeof b64 !== 'boolean') {
            throw new JWSInvalid('The "b64" (base64url-encode payload) Header Parameter must be a boolean');
        }
    }
    const { alg } = joseHeader;
    if (typeof alg !== 'string' || !alg) {
        throw new JWSInvalid('JWS "alg" (Algorithm) Header Parameter missing or invalid');
    }
    const algorithms = options && validateAlgorithms('algorithms', options.algorithms);
    if (algorithms && !algorithms.has(alg)) {
        throw new JOSEAlgNotAllowed('"alg" (Algorithm) Header Parameter value not allowed');
    }
    if (b64) {
        if (typeof jws.payload !== 'string') {
            throw new JWSInvalid('JWS Payload must be a string');
        }
    }
    else if (typeof jws.payload !== 'string' && !(jws.payload instanceof Uint8Array)) {
        throw new JWSInvalid('JWS Payload must be a string or an Uint8Array instance');
    }
    let resolvedKey = false;
    if (typeof key === 'function') {
        key = await key(parsedProt, jws);
        resolvedKey = true;
    }
    checkKeyType(alg, key, 'verify');
    const data = concat(encoder.encode(jws.protected ?? ''), encoder.encode('.'), typeof jws.payload === 'string' ? encoder.encode(jws.payload) : jws.payload);
    let signature;
    try {
        signature = decode(jws.signature);
    }
    catch {
        throw new JWSInvalid('Failed to base64url decode the signature');
    }
    const verified = await verify(alg, key, signature, data);
    if (!verified) {
        throw new JWSSignatureVerificationFailed();
    }
    let payload;
    if (b64) {
        try {
            payload = decode(jws.payload);
        }
        catch {
            throw new JWSInvalid('Failed to base64url decode the payload');
        }
    }
    else if (typeof jws.payload === 'string') {
        payload = encoder.encode(jws.payload);
    }
    else {
        payload = jws.payload;
    }
    const result = { payload };
    if (jws.protected !== undefined) {
        result.protectedHeader = parsedProt;
    }
    if (jws.header !== undefined) {
        result.unprotectedHeader = jws.header;
    }
    if (resolvedKey) {
        return { ...result, key };
    }
    return result;
}

async function compactVerify(jws, key, options) {
    if (jws instanceof Uint8Array) {
        jws = decoder.decode(jws);
    }
    if (typeof jws !== 'string') {
        throw new JWSInvalid('Compact JWS must be a string or Uint8Array');
    }
    const { 0: protectedHeader, 1: payload, 2: signature, length } = jws.split('.');
    if (length !== 3) {
        throw new JWSInvalid('Invalid Compact JWS');
    }
    const verified = await flattenedVerify({ payload, protected: protectedHeader, signature }, key, options);
    const result = { payload: verified.payload, protectedHeader: verified.protectedHeader };
    if (typeof key === 'function') {
        return { ...result, key: verified.key };
    }
    return result;
}

var epoch = (date) => Math.floor(date.getTime() / 1000);

const minute = 60;
const hour = minute * 60;
const day = hour * 24;
const week = day * 7;
const year = day * 365.25;
const REGEX = /^(\+|\-)? ?(\d+|\d+\.\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)(?: (ago|from now))?$/i;
var secs = (str) => {
    const matched = REGEX.exec(str);
    if (!matched || (matched[4] && matched[1])) {
        throw new TypeError('Invalid time period format');
    }
    const value = parseFloat(matched[2]);
    const unit = matched[3].toLowerCase();
    let numericDate;
    switch (unit) {
        case 'sec':
        case 'secs':
        case 'second':
        case 'seconds':
        case 's':
            numericDate = Math.round(value);
            break;
        case 'minute':
        case 'minutes':
        case 'min':
        case 'mins':
        case 'm':
            numericDate = Math.round(value * minute);
            break;
        case 'hour':
        case 'hours':
        case 'hr':
        case 'hrs':
        case 'h':
            numericDate = Math.round(value * hour);
            break;
        case 'day':
        case 'days':
        case 'd':
            numericDate = Math.round(value * day);
            break;
        case 'week':
        case 'weeks':
        case 'w':
            numericDate = Math.round(value * week);
            break;
        default:
            numericDate = Math.round(value * year);
            break;
    }
    if (matched[1] === '-' || matched[4] === 'ago') {
        return -numericDate;
    }
    return numericDate;
};

const normalizeTyp = (value) => value.toLowerCase().replace(/^application\//, '');
const checkAudiencePresence = (audPayload, audOption) => {
    if (typeof audPayload === 'string') {
        return audOption.includes(audPayload);
    }
    if (Array.isArray(audPayload)) {
        return audOption.some(Set.prototype.has.bind(new Set(audPayload)));
    }
    return false;
};
var jwtPayload = (protectedHeader, encodedPayload, options = {}) => {
    const { typ } = options;
    if (typ &&
        (typeof protectedHeader.typ !== 'string' ||
            normalizeTyp(protectedHeader.typ) !== normalizeTyp(typ))) {
        throw new JWTClaimValidationFailed('unexpected "typ" JWT header value', 'typ', 'check_failed');
    }
    let payload;
    try {
        payload = JSON.parse(decoder.decode(encodedPayload));
    }
    catch {
    }
    if (!isObject(payload)) {
        throw new JWTInvalid('JWT Claims Set must be a top-level JSON object');
    }
    const { requiredClaims = [], issuer, subject, audience, maxTokenAge } = options;
    const presenceCheck = [...requiredClaims];
    if (maxTokenAge !== undefined)
        presenceCheck.push('iat');
    if (audience !== undefined)
        presenceCheck.push('aud');
    if (subject !== undefined)
        presenceCheck.push('sub');
    if (issuer !== undefined)
        presenceCheck.push('iss');
    for (const claim of new Set(presenceCheck.reverse())) {
        if (!(claim in payload)) {
            throw new JWTClaimValidationFailed(`missing required "${claim}" claim`, claim, 'missing');
        }
    }
    if (issuer && !(Array.isArray(issuer) ? issuer : [issuer]).includes(payload.iss)) {
        throw new JWTClaimValidationFailed('unexpected "iss" claim value', 'iss', 'check_failed');
    }
    if (subject && payload.sub !== subject) {
        throw new JWTClaimValidationFailed('unexpected "sub" claim value', 'sub', 'check_failed');
    }
    if (audience &&
        !checkAudiencePresence(payload.aud, typeof audience === 'string' ? [audience] : audience)) {
        throw new JWTClaimValidationFailed('unexpected "aud" claim value', 'aud', 'check_failed');
    }
    let tolerance;
    switch (typeof options.clockTolerance) {
        case 'string':
            tolerance = secs(options.clockTolerance);
            break;
        case 'number':
            tolerance = options.clockTolerance;
            break;
        case 'undefined':
            tolerance = 0;
            break;
        default:
            throw new TypeError('Invalid clockTolerance option type');
    }
    const { currentDate } = options;
    const now = epoch(currentDate || new Date());
    if ((payload.iat !== undefined || maxTokenAge) && typeof payload.iat !== 'number') {
        throw new JWTClaimValidationFailed('"iat" claim must be a number', 'iat', 'invalid');
    }
    if (payload.nbf !== undefined) {
        if (typeof payload.nbf !== 'number') {
            throw new JWTClaimValidationFailed('"nbf" claim must be a number', 'nbf', 'invalid');
        }
        if (payload.nbf > now + tolerance) {
            throw new JWTClaimValidationFailed('"nbf" claim timestamp check failed', 'nbf', 'check_failed');
        }
    }
    if (payload.exp !== undefined) {
        if (typeof payload.exp !== 'number') {
            throw new JWTClaimValidationFailed('"exp" claim must be a number', 'exp', 'invalid');
        }
        if (payload.exp <= now - tolerance) {
            throw new JWTExpired('"exp" claim timestamp check failed', 'exp', 'check_failed');
        }
    }
    if (maxTokenAge) {
        const age = now - payload.iat;
        const max = typeof maxTokenAge === 'number' ? maxTokenAge : secs(maxTokenAge);
        if (age - tolerance > max) {
            throw new JWTExpired('"iat" claim timestamp check failed (too far in the past)', 'iat', 'check_failed');
        }
        if (age < 0 - tolerance) {
            throw new JWTClaimValidationFailed('"iat" claim timestamp check failed (it should be in the past)', 'iat', 'check_failed');
        }
    }
    return payload;
};

async function jwtVerify(jwt, key, options) {
    const verified = await compactVerify(jwt, key, options);
    if (verified.protectedHeader.crit?.includes('b64') && verified.protectedHeader.b64 === false) {
        throw new JWTInvalid('JWTs MUST NOT use unencoded payload');
    }
    const payload = jwtPayload(verified.protectedHeader, verified.payload, options);
    const result = { payload, protectedHeader: verified.protectedHeader };
    if (typeof key === 'function') {
        return { ...result, key: verified.key };
    }
    return result;
}

const getTokenVerificationMetadataPromise = (tokenVerificationMetadataPromise) => __awaiter(void 0, void 0, void 0, function* () {
    const tokenVerificationMetadata = yield tokenVerificationMetadataPromise;
    if (!tokenVerificationMetadata) {
        const errorMessage = `Auth library not initialized, rejecting request. 
            This can mean that your API key was invalid or that the request to fetch token metadata failed. 
            Sometimes, this can happen if you are deploying to an environment without external internet access. 
            One workaround is to skip the fetch by passing in manualTokenVerificationMetadata to the initialization function.`;
        console.error(errorMessage);
        throw new UnexpectedException(errorMessage);
    }
    try {
        const publicKey = yield importSPKI(tokenVerificationMetadata.verifierKey, "RS256");
        return {
            publicKey,
            tokenVerificationMetadata,
        };
    }
    catch (e) {
        const publicKeyErrorMessage = "Error initializing auth library. Unable to import public key";
        console.error(publicKeyErrorMessage);
        throw new UnexpectedException(publicKeyErrorMessage);
    }
});

function validateAuthUrl(authUrl) {
    try {
        return new URL(authUrl);
    }
    catch (e) {
        console.error("Invalid authUrl", e);
        throw new Error("Unable to initialize auth client");
    }
}

function initBaseAuth(opts) {
    const authUrl = validateAuthUrl(opts.authUrl);
    const integrationApiKey = opts.apiKey;
    const apis = getApis(authUrl, integrationApiKey);
    // A promise that resolves to the token verification metadata, whether it's fetched or manually provided
    const tokenVerificationMetadataPromise = opts.manualTokenVerificationMetadata
        ? Promise.resolve(opts.manualTokenVerificationMetadata)
        : apis.fetchTokenVerificationMetadata().catch((err) => {
            console.error("Error initializing auth library. ", err);
        });
    // A promise that resolves to the token verification metadata with the public key imported
    const tokenVerificationMetadataWithPublicKeyPromise = getTokenVerificationMetadataPromise(tokenVerificationMetadataPromise);
    const validateAccessTokenAndGetUserClass = wrapValidateAccessTokenAndGetUserClass(tokenVerificationMetadataWithPublicKeyPromise);
    const validateAccessTokenAndGetUser = wrapValidateAccessTokenAndGetUser(tokenVerificationMetadataWithPublicKeyPromise);
    const validateAccessTokenAndGetUserWithOrgInfo = wrapValidateAccessTokenAndGetUserWithOrgInfo(tokenVerificationMetadataWithPublicKeyPromise);
    const validateAccessTokenAndGetUserWithOrgInfoWithMinimumRole = wrapValidateAccessTokenAndGetUserWithOrgInfoWithMinimumRole(tokenVerificationMetadataWithPublicKeyPromise);
    const validateAccessTokenAndGetUserWithOrgInfoWithExactRole = wrapValidateAccessTokenAndGetUserWithOrgInfoWithExactRole(tokenVerificationMetadataWithPublicKeyPromise);
    const validateAccessTokenAndGetUserWithOrgInfoWithPermission = wrapValidateAccessTokenAndGetUserWithOrgInfoWithPermission(tokenVerificationMetadataWithPublicKeyPromise);
    const validateAccessTokenAndGetUserWithOrgInfoWithAllPermissions = wrapValidateAccessTokenAndGetUserWithOrgInfoWithAllPermissions(tokenVerificationMetadataWithPublicKeyPromise);
    // Note: We exclude fetchTokenVerificationMetadata from the returned object
    // because we have explicit usage of it above. Thus, it is not used in the returned object.
    const nodeApis = __rest(apis, ["fetchTokenVerificationMetadata"]);
    return Object.assign({ 
        // validate functions
        validateAccessTokenAndGetUserClass,
        validateAccessTokenAndGetUser,
        validateAccessTokenAndGetUserWithOrgInfo,
        validateAccessTokenAndGetUserWithOrgInfoWithMinimumRole,
        validateAccessTokenAndGetUserWithOrgInfoWithExactRole,
        validateAccessTokenAndGetUserWithOrgInfoWithPermission,
        validateAccessTokenAndGetUserWithOrgInfoWithAllPermissions }, nodeApis);
}
// wrapper function that returns a UserClass object
function wrapValidateAccessTokenAndGetUserClass(tokenVerificationMetadataWithPublicKeyPromise) {
    return function validateAccessTokenAndGetUser(authorizationHeader) {
        return __awaiter(this, void 0, void 0, function* () {
            const user = yield extractAndVerifyBearerToken(tokenVerificationMetadataWithPublicKeyPromise, authorizationHeader, true);
            return new UserClass(user);
        });
    };
}
// wrapper function with no validation
function wrapValidateAccessTokenAndGetUser(tokenVerificationMetadataWithPublicKeyPromise) {
    return function validateAccessTokenAndGetUser(authorizationHeader) {
        return __awaiter(this, void 0, void 0, function* () {
            return extractAndVerifyBearerToken(tokenVerificationMetadataWithPublicKeyPromise, authorizationHeader);
        });
    };
}
// The following four functions are wrappers around our four validations: isRole, atLeastRole, hasPermission, hasAllPermissions
// Each function returns an OrgMemberInfo object
function wrapValidateAccessTokenAndGetUserWithOrgInfo(tokenVerificationMetadataWithPublicKeyPromise) {
    return function validateAccessTokenAndGetUserWithOrgInfo(authorizationHeader, requiredOrgInfo) {
        return __awaiter(this, void 0, void 0, function* () {
            const user = yield extractAndVerifyBearerToken(tokenVerificationMetadataWithPublicKeyPromise, authorizationHeader);
            const orgMemberInfo = validateOrgAccessAndGetOrgMemberInfo(user, requiredOrgInfo);
            return { user, orgMemberInfo };
        });
    };
}
function wrapValidateAccessTokenAndGetUserWithOrgInfoWithMinimumRole(tokenVerificationMetadataWithPublicKeyPromise) {
    return function validateAccessTokenAndGetUserWithOrgInfo(authorizationHeader, requiredOrgInfo, minimumRole) {
        return __awaiter(this, void 0, void 0, function* () {
            const user = yield extractAndVerifyBearerToken(tokenVerificationMetadataWithPublicKeyPromise, authorizationHeader);
            const orgMemberInfo = validateOrgAccessAndGetOrgMemberInfoWithMinimumRole(user, requiredOrgInfo, minimumRole);
            return { user, orgMemberInfo };
        });
    };
}
function wrapValidateAccessTokenAndGetUserWithOrgInfoWithExactRole(tokenVerificationMetadataWithPublicKeyPromise) {
    return function validateAccessTokenAndGetUserWithOrgInfo(authorizationHeader, requiredOrgInfo, exactRole) {
        return __awaiter(this, void 0, void 0, function* () {
            const user = yield extractAndVerifyBearerToken(tokenVerificationMetadataWithPublicKeyPromise, authorizationHeader);
            const orgMemberInfo = validateOrgAccessAndGetOrgMemberInfoWithExactRole(user, requiredOrgInfo, exactRole);
            return { user, orgMemberInfo };
        });
    };
}
function wrapValidateAccessTokenAndGetUserWithOrgInfoWithPermission(tokenVerificationMetadataWithPublicKeyPromise) {
    return function validateAccessTokenAndGetUserWithOrgInfo(authorizationHeader, requiredOrgInfo, permission) {
        return __awaiter(this, void 0, void 0, function* () {
            const user = yield extractAndVerifyBearerToken(tokenVerificationMetadataWithPublicKeyPromise, authorizationHeader);
            const orgMemberInfo = validateOrgAccessAndGetOrgMemberInfoWithPermission(user, requiredOrgInfo, permission);
            return { user, orgMemberInfo };
        });
    };
}
function wrapValidateAccessTokenAndGetUserWithOrgInfoWithAllPermissions(tokenVerificationMetadataWithPublicKeyPromise) {
    return function validateAccessTokenAndGetUserWithOrgInfo(authorizationHeader, requiredOrgInfo, permissions) {
        return __awaiter(this, void 0, void 0, function* () {
            const user = yield extractAndVerifyBearerToken(tokenVerificationMetadataWithPublicKeyPromise, authorizationHeader);
            const orgMemberInfo = validateOrgAccessAndGetOrgMemberInfoWithAllPermissions(user, requiredOrgInfo, permissions);
            return { user, orgMemberInfo };
        });
    };
}
// Validator functions
function validateOrgAccessAndGetOrgMemberInfo(user, requiredOrgInfo) {
    const orgMemberInfo = getUserInfoInOrg(requiredOrgInfo, user.orgIdToOrgMemberInfo);
    if (!orgMemberInfo) {
        throw new ForbiddenException(`User is not a member of org ${JSON.stringify(requiredOrgInfo)}`);
    }
    return orgMemberInfo;
}
function validateOrgAccessAndGetOrgMemberInfoWithMinimumRole(user, requiredOrgInfo, minimumRole) {
    const orgMemberInfo = getUserInfoInOrg(requiredOrgInfo, user.orgIdToOrgMemberInfo);
    if (!orgMemberInfo) {
        throw new ForbiddenException(`User is not a member of org ${JSON.stringify(requiredOrgInfo)}`);
    }
    if (!orgMemberInfo.isAtLeastRole(minimumRole)) {
        throw new ForbiddenException(`User's roles don't contain the minimum role (${minimumRole})`);
    }
    return orgMemberInfo;
}
function validateOrgAccessAndGetOrgMemberInfoWithExactRole(user, requiredOrgInfo, exactRole) {
    const orgMemberInfo = getUserInfoInOrg(requiredOrgInfo, user.orgIdToOrgMemberInfo);
    if (!orgMemberInfo) {
        throw new ForbiddenException(`User is not a member of org ${JSON.stringify(requiredOrgInfo)}`);
    }
    if (!orgMemberInfo.isRole(exactRole)) {
        throw new ForbiddenException(`User's assigned role isn't the required role (${exactRole})`);
    }
    return orgMemberInfo;
}
function validateOrgAccessAndGetOrgMemberInfoWithPermission(user, requiredOrgInfo, permission) {
    const orgMemberInfo = getUserInfoInOrg(requiredOrgInfo, user.orgIdToOrgMemberInfo);
    if (!orgMemberInfo) {
        throw new ForbiddenException(`User is not a member of org ${JSON.stringify(requiredOrgInfo)}`);
    }
    if (!orgMemberInfo.hasPermission(permission)) {
        throw new ForbiddenException(`User's permissions don't contain the required permission (${permission})`);
    }
    return orgMemberInfo;
}
function validateOrgAccessAndGetOrgMemberInfoWithAllPermissions(user, requiredOrgInfo, permissions) {
    const orgMemberInfo = getUserInfoInOrg(requiredOrgInfo, user.orgIdToOrgMemberInfo);
    if (!orgMemberInfo) {
        throw new ForbiddenException(`User is not a member of org ${JSON.stringify(requiredOrgInfo)}`);
    }
    if (!orgMemberInfo.hasAllPermissions(permissions)) {
        throw new ForbiddenException(`User's permissions don't contain all the required permissions (${permissions})`);
    }
    return orgMemberInfo;
}
// Miscellaneous functions
function getUserInfoInOrg(requiredOrgInfo, orgIdToOrgMemberInfo) {
    if (!orgIdToOrgMemberInfo) {
        return undefined;
    }
    else if (requiredOrgInfo.orgId) {
        // If we are looking for an orgId, we can do a direct lookup
        if (!orgIdToOrgMemberInfo.hasOwnProperty(requiredOrgInfo.orgId)) {
            return undefined;
        }
        const orgMemberInfo = orgIdToOrgMemberInfo[requiredOrgInfo.orgId];
        // We also need to verify the orgName matches, if specified
        if (requiredOrgInfo.orgName && orgNameMatches(requiredOrgInfo.orgName, orgMemberInfo)) {
            return orgMemberInfo;
        }
        else if (requiredOrgInfo.orgName) {
            return undefined;
        }
        else {
            return orgMemberInfo;
        }
    }
    else if (requiredOrgInfo.orgName) {
        // We know there's no required orgId so just iterate over orgMemberInfos looking for a matching urlSafeOrgName
        for (const orgMemberInfo of Object.values(orgIdToOrgMemberInfo)) {
            if (orgNameMatches(requiredOrgInfo.orgName, orgMemberInfo)) {
                return orgMemberInfo;
            }
        }
        return undefined;
    }
    else {
        return undefined;
    }
}
function orgNameMatches(orgName, orgMemberInfo) {
    return orgName === orgMemberInfo.orgName || orgName === orgMemberInfo.urlSafeOrgName;
}
function extractAndVerifyBearerToken(tokenVerificationMetadataWithPublicKeyPromise, authorizationHeader, allowMissingBearerPrefix = false) {
    return __awaiter(this, void 0, void 0, function* () {
        const tokenVerificationMetadataWithPublicKey = yield tokenVerificationMetadataWithPublicKeyPromise;
        const { publicKey, tokenVerificationMetadata } = tokenVerificationMetadataWithPublicKey;
        const bearerToken = extractBearerToken(authorizationHeader, allowMissingBearerPrefix);
        return verifyToken(bearerToken, tokenVerificationMetadata, publicKey);
    });
}
function extractBearerToken(authHeader, allowMissingBearerPrefix = false) {
    if (!authHeader) {
        throw new UnauthorizedException("No authorization header found.");
    }
    const authHeaderParts = authHeader.split(" ");
    if (authHeaderParts.length === 1 && allowMissingBearerPrefix) {
        return authHeaderParts[0];
    }
    else if (authHeaderParts.length !== 2 || authHeaderParts[0].toLowerCase() !== "bearer") {
        throw new UnauthorizedException("Invalid authorization header. Expected: Bearer {accessToken}");
    }
    return authHeaderParts[1];
}
function verifyToken(bearerToken, tokenVerificationMetadata, publicKey) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const { payload } = yield jwtVerify(bearerToken, publicKey, {
                algorithms: ["RS256"],
                issuer: tokenVerificationMetadata.issuer,
            });
            return toUser(payload);
        }
        catch (e) {
            if (e instanceof Error) {
                throw new UnauthorizedException(e.message);
            }
            else {
                throw new UnauthorizedException("Unable to decode jwt");
            }
        }
    });
}
function handleError(e, opts) {
    if (opts && opts.logError) {
        console.error(e);
    }
    const detailedError = opts && opts.returnDetailedErrorToUser;
    if (e instanceof UnauthorizedException) {
        return {
            status: 401,
            message: detailedError ? e.message : "Unauthorized",
        };
    }
    else if (e instanceof ForbiddenException) {
        return {
            status: 403,
            message: detailedError ? e.message : "Forbidden",
        };
    }
    else {
        return {
            status: 401,
            message: "Unauthorized",
        };
    }
}

export { AccessTokenCreationException, AddUserToOrgException, ApiKeyCreateException, ApiKeyDeleteException, ApiKeyFetchException, ApiKeyUpdateException, ApiKeyValidateException, ApiKeyValidateRateLimitedException, BadRequestException, ChangeUserRoleInOrgException, CreateOrgException, CreateUserException, FeatureGatedException, ForbiddenException, IncorrectMfaCodeException, InvalidRequestFieldsException, MagicLinkCreationException, MfaNotEnabledException, MigrateUserException, MigrateUserPasswordException, OrgMemberInfo, RateLimitedException, RemoveUserFromOrgException, RevokePendingOrgInviteException, UnauthorizedException, UnexpectedException, UpdateOrgException, UpdateUserEmailException, UpdateUserMetadataException, UpdateUserPasswordException, UserClass, UserNotFoundException, handleError, initBaseAuth, toOrgIdToOrgMemberInfo, toUser };
//# sourceMappingURL=index.es.js.map
